C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c COMPACT ROM(COMPACT) OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          #include <string.h>
   6          
   7          typedef enum
   8          {
   9                  INITIAL = 0,
  10                  CONNECTING,
  11                  CONNECTED,
  12                  PROGRAM_EEPROM_PAGE,
  13                  VERIFY_EEPROM_PAGE,
  14                  READ_EEPROM_PAGE,
  15                  FAILED,
  16                  DONE
  17          }State;
  18          
  19          sbit CONNECTED_LED   = P3^2;
  20          sbit PROGRAM_LED     = P3^3;
  21          sbit VERIFY_LED      = P3^4;
  22          
  23          void displayState(int state)
  24          {                                       
  25   1              CONNECTED_LED = (state & 0x01) ? 0 : 1;
  26   1              PROGRAM_LED = (state & 0x02) ? 0 : 1;
  27   1              VERIFY_LED = (state & 0x04) ? 0 : 1;
  28   1      }
  29          
  30          ////////////////////////////////////////////////////////////////////
  31          #define EEPROM_ADDRESS_L P0
  32          #define EEPROM_ADDRESS_H P1
  33          #define EEPROM_DATA P2
  34          
  35          sbit EEPROM_WR     = P3^7;
  36          sbit EEPROM_OE     = P3^6;
  37          sbit EEPROM_CE     = P3^5;
  38          
  39          #define SET_WR()                                        EEPROM_WR = 1
  40          #define SET_OE()                                        EEPROM_OE = 1
  41          #define SET_CE()                                        EEPROM_CE = 1
  42          #define CLR_WR()                                        EEPROM_WR = 0
  43          #define CLR_OE()                                        EEPROM_OE = 0
  44          #define CLR_CE()                                        EEPROM_CE = 0
  45          #define GET_WR()                                        EEPROM_WR
  46          #define GET_OE()                                        EEPROM_OE
  47          #define GET_CE()                                        EEPROM_CE
  48          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  49          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
  50          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  51          #define GET_EEPROM_DATA()                       EEPROM_DATA
  52          
  53          void setAddress(unsigned int addr)
  54          {
  55   1              SET_EEPROM_ADDRESS_L((addr    ) & 0xff);
C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 2   

  56   1              SET_EEPROM_ADDRESS_H((addr>>8 ) & 0xff);
  57   1      }
  58          
  59          void setData(unsigned char dat)
  60          {
  61   1              SET_EEPROM_DATA(dat);
  62   1      }
  63          
  64          unsigned char getData()
  65          {
  66   1              return GET_EEPROM_DATA();
  67   1      }
  68          
  69          void initEEPROWriter()
  70          {
  71   1              setAddress(0xffff);
  72   1              setData(0xff);
  73   1              SET_WR();
  74   1              SET_OE();
  75   1              SET_CE();
  76   1              
  77   1              delayMS(100);
  78   1      }
  79          
  80          void beginWriteByte()
  81          {
  82   1              setAddress(0xffff);
  83   1              setData(0xff);
  84   1      
  85   1              SET_WR();
  86   1              SET_OE();
  87   1              CLR_CE();
  88   1      }
  89          
  90          void writeByte(unsigned int address, unsigned char dat)
  91          {
  92   1              setAddress(address);
  93   1              setData(dat);
  94   1      
  95   1              //CLR_CE();
  96   1              //delay1us();
  97   1              CLR_WR();
  98   1      
  99   1              //SET_CE();
 100   1              //delay1us();
 101   1              SET_WR();
 102   1      }
 103           
 104          void endWriteByte()
 105          {
 106   1              SET_CE();
 107   1              delayMS(100);
 108   1      }
 109          
 110          void beginReadByte()
 111          {
 112   1              setAddress(0xffff);
 113   1              setData(0xff);
 114   1      
 115   1              SET_WR();
 116   1              SET_OE();
 117   1              CLR_CE();
C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 3   

 118   1      }
 119          
 120          unsigned char readByte(unsigned int address)
 121          {
 122   1              unsigned char dat;
 123   1      
 124   1              setAddress(address);
 125   1              setData(0xff);
 126   1      
 127   1              //CLR_CE();
 128   1              CLR_OE();
 129   1              delay1us();
 130   1      
 131   1              dat = getData();
 132   1      
 133   1              //SET_CE();
 134   1              SET_OE();
 135   1              delay1us();
 136   1      
 137   1              return dat;
 138   1      }
 139          
 140          void endReadByte()
 141          {
 142   1              SET_CE();
 143   1              delayMS(100);
 144   1      }
 145          
 146          void enableDataProtection()
 147          {
 148   1              writeByte(0x5555, 0xaa);
 149   1              writeByte(0x2aaa, 0x55);
 150   1              writeByte(0x5555, 0xa0);
 151   1      }
 152          
 153          void disableDataProtection()
 154          {
 155   1              writeByte(0x5555, 0xaa);
 156   1              writeByte(0x2aaa, 0x55);
 157   1              writeByte(0x5555, 0x80);
 158   1              writeByte(0x5555, 0xaa);
 159   1              writeByte(0x2aaa, 0x55);
 160   1              writeByte(0x5555, 0x20);
 161   1      }
 162          
 163          void programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 164          {
 165   1              int i;
 166   1      
 167   1              beginWriteByte();
 168   1              disableDataProtection();
 169   1              //endWriteByte();
 170   1      
 171   1              //beginWriteByte();
 172   1              for(i=0; i<size; i++)
 173   1              {
 174   2                      writeByte(startAddress+i, dat[i]);
 175   2              }
 176   1              endWriteByte(); 
 177   1      }
 178          
 179          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 4   

 180          {
 181   1              int i;
 182   1              unsigned char d;
 183   1      
 184   1              beginReadByte();
 185   1              for(i=0; i<size; i++)
 186   1              {
 187   2                      d = readByte(startAddress+i);
 188   2                      //serialSendData(&d, 1, 500); // ack
 189   2                              
 190   2                      if(d!=dat[i])
 191   2                              return 0;
 192   2              }
 193   1              endReadByte();
 194   1              
 195   1              return -1;
 196   1      }
 197          
 198          void readPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 199          {
 200   1              int i;
 201   1      
 202   1              beginReadByte();
 203   1              for(i=0; i<size; i++)
 204   1              {
 205   2                      dat[i] = readByte(startAddress+i);
 206   2              }
 207   1              endReadByte();
 208   1      }
 209          
 210          unsigned long int convertToBigEndian32(unsigned long int v)
 211          {
 212   1              return ((v>>24) & 0x000000ff) | ((v>>8) & 0x0000ff00) | ((v<<8) & 0x00ff0000) | ((v<<24) & 0xff00000);
 213   1      }
 214          
 215          unsigned int convertToBigEndian16(unsigned int v)
 216          {
 217   1              return ((v>>8) & 0x00ff) | ((v<<8) & 0xff00);
 218   1      }
 219          
 220          void test()
 221          {
 222   1              unsigned char rxBuffer1[] = { 'A', 0x00, 0x01, 0x00, 0x00 };
 223   1              unsigned long int addr = convertToBigEndian32(*((unsigned long int*)(rxBuffer1+1  )));
 224   1      
 225   1              for(addr=0; addr<1024; addr+=1)
 226   1                      setAddress(addr);
 227   1      }
 228          
 229          void main()
 230          {
 231   1              #if 0
                      char test = 0;
                      serialInitialize(9600);
              
                      programPage(0, temp, 32);
                      test = verifyPage(0, temp, 32);
                      while(1)
                      {
                              if(!test)
                              {
                                      delayMS(250);
C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 5   

                                      EEPROM_CE      = ~EEPROM_CE;
                              }
                              else
                              {
                                      EEPROM_CE      = 0;
                              }
                      };
                      #else
 250   1              State state = INITIAL;
 251   1              char* rxBuffer = 0;
 252   1              //test();       
 253   1      
 254   1              while(1)
 255   1              {
 256   2                      switch(state)
 257   2                      {
 258   3                              case INITIAL:
 259   3                              {
 260   4                                      displayState(state);                            
 261   4                                      serialInitialize(9600);
 262   4                                      state = CONNECTING;
 263   4                              }
 264   3                              break;
 265   3      
 266   3                              case CONNECTING:
 267   3                              {
 268   4                                      displayState(state);                            
 269   4                                      rxBuffer = serialReceiveData(1, -1); // wait for command C
 270   4      
 271   4                                      //CONNECTED_LED = ~CONNECTED_LED;
 272   4                                      if(*rxBuffer == 'C') 
 273   4                                      {
 274   5                                              serialSendData("c", 1, -1); // ack
 275   5                                              
 276   5                                              state = CONNECTED;       // connected
 277   5                                      }
 278   4                                      else
 279   4                                      {
 280   5                                              state = INITIAL;        // set next baud
 281   5                                      }                               
 282   4                              }
 283   3                              break;
 284   3                                      
 285   3                              case CONNECTED:
 286   3                              {
 287   4                                      displayState(state);                            
 288   4                                      // CONNECTED_LED = 1;           
 289   4                              
 290   4                                      rxBuffer = serialReceiveData(1, -1); // wait for command P or V
 291   4                                      if(*rxBuffer == 'P')
 292   4                                      {
 293   5                                              serialSendData("p", 1, 500);     // ack
 294   5                                              
 295   5                                              state = PROGRAM_EEPROM_PAGE;     // program
 296   5                                      }
 297   4                                      else if(*rxBuffer == 'V')
 298   4                                      {
 299   5                                              serialSendData("v", 1, 500);     // ack
 300   5                                              
 301   5                                              state = VERIFY_EEPROM_PAGE;      // verify
 302   5                                      }       
 303   4                                      else if(*rxBuffer == 'R')
C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 6   

 304   4                                      {
 305   5                                              serialSendData("r", 1, 500);     // ack
 306   5                                              
 307   5                                              state = READ_EEPROM_PAGE;        // verify
 308   5                                      }                                       
 309   4                                      else if(*rxBuffer == 'D')
 310   4                                      {
 311   5                                              serialSendData('d', 1, 500);     // ack
 312   5                                              
 313   5                                              state = DONE;    // verify
 314   5                                      }                                       
 315   4                                      else
 316   4                                      {
 317   5                                              state = CONNECTED; // unknown command, again
 318   5                                      }
 319   4                              }
 320   3                              break;
 321   3                                      
 322   3                              case PROGRAM_EEPROM_PAGE:
 323   3                              {
 324   4                                      unsigned int address;
 325   4                                      unsigned int size;
 326   4                                      
 327   4                                      displayState(state);
 328   4                                      
 329   4                                      rxBuffer = serialReceiveData(1+2+2, -1); // wait for command P or V
 330   4                                      if(*rxBuffer == 'D')
 331   4                                      {
 332   5                                              serialSendData("d", 1, -1);      // ack failed
 333   5                                                      
 334   5                                              state = DONE; // unknown command, again
 335   5                                      }                               
 336   4                                      else if(*rxBuffer == 'A')
 337   4                                      {
 338   5                                              address = convertToBigEndian16(*((unsigned int*)(rxBuffer+1  )));
 339   5                                              size    = convertToBigEndian16(*((unsigned int*)(rxBuffer+1+2)));
 340   5      
 341   5                                              serialSendData("a", 1, -1);
 342   5                                              // serialSendData(&address, 2, -1);
 343   5                                              // serialSendData(&size, 2, -1);
 344   5                                              
 345   5                                              //PROGRAM_LED     = 1;
 346   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V      
 347   5                                              programPage(address, rxBuffer, size);
 348   5                                              // serialSendData(rxBuffer, size, -1);   // ack failed                                  
 349   5                                              if(verifyPage(address, rxBuffer, size))
 350   5                                              {
 351   6                      
 352   6                                                      //PROGRAM_LED     = 0;
 353   6                                              
 354   6                                                      serialSendData("s", 1, -1);      // ack success
 355   6      
 356   6                                                      state = PROGRAM_EEPROM_PAGE; // unknown command, again
 357   6                                              }
 358   5                                              else
 359   5                                              {
 360   6                                                      //PROGRAM_LED     = 0;
 361   6                                              
 362   6                                                      serialSendData("f", 1, -1);      // ack failed
 363   6                                                      
 364   6                                                      state = FAILED; // unknown command, again
 365   6                                              }
C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 7   

 366   5                                      }
 367   4                                      else
 368   4                                      {
 369   5                                              serialSendData("f", 1, -1);      // ack failed
 370   5      
 371   5                                              state = FAILED; // unknown command, again
 372   5                                      }
 373   4                              }
 374   3                              break;
 375   3                              
 376   3                              case VERIFY_EEPROM_PAGE:
 377   3                              {
 378   4                                      unsigned int address;
 379   4                                      unsigned int size;
 380   4                                      
 381   4                                      displayState(state);
 382   4                                      
 383   4                                      rxBuffer = serialReceiveData(1+2+2, -1); // wait for command P or V
 384   4                                      if(*rxBuffer == 'D')
 385   4                                      {
 386   5                                              serialSendData("d", 1, -1);      // ack failed
 387   5                                                      
 388   5                                              state = DONE; // unknown command, again
 389   5                                      }                               
 390   4                                      else if(*rxBuffer == 'A')
 391   4                                      {
 392   5                                              address = convertToBigEndian16(*((unsigned int*)(rxBuffer+1  )));
 393   5                                              size    = convertToBigEndian16(*((unsigned int*)(rxBuffer+1+2)));
 394   5                                              
 395   5                                              serialSendData("a", 1, -1);
 396   5      
 397   5                                              //PROGRAM_LED     = 1;
 398   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
 399   5                                              //programPage(address, rxBuffer, size);
 400   5                                              if(verifyPage(address, rxBuffer, size))
 401   5                                              {
 402   6                                                      //PROGRAM_LED     = 0;
 403   6                                              
 404   6                                                      serialSendData("s", 1, -1);      // ack success
 405   6      
 406   6                                                      state = VERIFY_EEPROM_PAGE; // unknown command, again
 407   6                                              }
 408   5                                              else
 409   5                                              {
 410   6                                                      //PROGRAM_LED     = 0;
 411   6                                              
 412   6                                                      serialSendData("f", 1, -1);      // ack failed
 413   6                                                      
 414   6                                                      state = FAILED; // unknown command, again
 415   6                                              }
 416   5                                      }
 417   4                                      else
 418   4                                      {
 419   5                                              serialSendData("f", 1, -1);      // ack failed
 420   5                                                      
 421   5                                              state = FAILED; // unknown command, again
 422   5                                      }
 423   4                              }
 424   3                              break;
 425   3                              
 426   3                              case READ_EEPROM_PAGE:
 427   3                              {
C51 COMPILER V9.01   MAIN                                                                  03/06/2019 17:40:32 PAGE 8   

 428   4                                      unsigned int address;
 429   4                                      unsigned int size;
 430   4                                      
 431   4                                      displayState(state);
 432   4                                      
 433   4                                      rxBuffer = serialReceiveData(1+2+2, -1); // wait for command P or V
 434   4                                      if(*rxBuffer == 'D')
 435   4                                      {
 436   5                                              serialSendData("d", 1, -1);      // ack failed
 437   5                                                      
 438   5                                              state = DONE; // unknown command, again
 439   5                                      }                               
 440   4                                      else if(*rxBuffer == 'A')
 441   4                                      {
 442   5                                              address = convertToBigEndian16(*((unsigned int*)(rxBuffer+1  )));
 443   5                                              size    = convertToBigEndian16(*((unsigned int*)(rxBuffer+1+2)));
 444   5                                              
 445   5                                              serialSendData("a", 1, -1);
 446   5      
 447   5                                              readPage(address, rxBuffer, size);
 448   5                                              
 449   5                                              serialSendData(rxBuffer, size, -1);
 450   5                                      }
 451   4                                      else
 452   4                                      {
 453   5                                              serialSendData("f", 1, -1);      // ack failed
 454   5                                                      
 455   5                                              state = FAILED; // unknown command, again
 456   5                                      }
 457   4                              }
 458   3                              break;                  
 459   3                              
 460   3                              case FAILED:
 461   3                              {       
 462   4                                      displayState(state);
 463   4                              }
 464   3                              break;
 465   3                              
 466   3                              case DONE:
 467   3                              {
 468   4                                      displayState(state);
 469   4                              }
 470   3                              break;
 471   3                      }
 472   2              }
 473   1              
 474   1              #endif
 475   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1338    ----
   CONSTANT SIZE    =     21    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      49
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
