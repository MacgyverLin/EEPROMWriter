C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          #include <string.h>
   6          
   7          typedef enum
   8          {
   9                  INITIAL = 0,
  10                  CONNECTING,
  11                  CONNECTED,
  12                  PROGRAM_EEPROM_PAGE,
  13                  VERIFY_EEPROM_PAGE,
  14                  FAILED,
  15                  DONE
  16          }State;
  17          
  18          sbit CONNECTED_LED   = P3^2;
  19          sbit PROGRAM_LED     = P3^3;
  20          sbit VERIFY_LED      = P3^4;
  21          
  22          void displayState(int state)
  23          {                                       
  24   1              CONNECTED_LED = (state & 0x01) ? 0 : 1;
  25   1              PROGRAM_LED = (state & 0x02) ? 0 : 1;
  26   1              VERIFY_LED = (state & 0x04) ? 0 : 1;
  27   1      }
  28          
  29          void delay()
  30          {
  31   1              unsigned int i = 0;
  32   1      
  33   1              while(i++<10000);
  34   1      }
  35          
  36          ////////////////////////////////////////////////////////////////////
  37          #define EEPROM_ADDRESS_L P0
  38          #define EEPROM_ADDRESS_H P1
  39          #define EEPROM_DATA P2
  40          
  41          sbit EEPROM_WR     = P3^7;
  42          sbit EEPROM_OE     = P3^6;
  43          sbit EEPROM_CE     = P3^5;
  44          
  45          #define SET_WR()                                        EEPROM_WR = 1
  46          #define SET_OE()                                        EEPROM_OE = 1
  47          #define SET_CE()                                        EEPROM_CE = 1
  48          #define CLR_WR()                                        EEPROM_WR = 0
  49          #define CLR_OE()                                        EEPROM_OE = 0
  50          #define CLR_CE()                                        EEPROM_CE = 0
  51          #define GET_WR()                                        EEPROM_WR
  52          #define GET_OE()                                        EEPROM_OE
  53          #define GET_CE()                                        EEPROM_CE
  54          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  55          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 2   

  56          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  57          #define GET_EEPROM_DATA()                       EEPROM_DATA
  58          
  59          void setAddress(unsigned int addr)
  60          {
  61   1              SET_EEPROM_ADDRESS_L(addr & 0xff);
  62   1              SET_EEPROM_ADDRESS_H(addr >> 8);
  63   1      }
  64          
  65          void setData(unsigned char dat)
  66          {
  67   1              SET_EEPROM_DATA(dat);
  68   1      }
  69          
  70          unsigned char getData()
  71          {
  72   1              return GET_EEPROM_DATA();
  73   1      }
  74          
  75          void initEEPROWriter()
  76          {
  77   1              setAddress(0xffff);
  78   1              setData(0xff);
  79   1              SET_WR();
  80   1              SET_OE();
  81   1              SET_CE();
  82   1              
  83   1              delayMS(10);
  84   1      }
  85          
  86          void beginWriteByte()
  87          {
  88   1              setAddress(0xffff);
  89   1              setData(0xff);
  90   1              SET_WR();
  91   1              SET_OE();
  92   1              SET_CE();
  93   1      }
  94          
  95          void writeByte(unsigned int address, unsigned char dat)
  96          {
  97   1              setAddress(address);
  98   1              setData(dat);
  99   1              delay1us();
 100   1      
 101   1              CLR_CE();
 102   1              delay1us();
 103   1              CLR_WR();
 104   1              delay1us();
 105   1      
 106   1              SET_CE();
 107   1              delay1us();
 108   1              SET_WR();
 109   1              delay1us();
 110   1      }
 111          
 112          void beginReadByte()
 113          {
 114   1              setAddress(0xffff);
 115   1              setData(0xff);
 116   1              delay1us();
 117   1      
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 3   

 118   1              SET_CE();
 119   1              SET_WR();
 120   1              SET_OE();
 121   1      }
 122          
 123          unsigned char readByte(unsigned int address)
 124          {
 125   1              unsigned char dat;
 126   1      
 127   1              setAddress(address);
 128   1              delay1us();
 129   1      
 130   1              CLR_CE();
 131   1              delay1us();
 132   1              CLR_OE();
 133   1              delay1us();
 134   1      
 135   1              dat = getData();
 136   1              delay1us();
 137   1      
 138   1              SET_CE();
 139   1              delay1us();
 140   1              SET_OE();
 141   1              delay1us();
 142   1      
 143   1              return dat;
 144   1      }
 145          
 146          void endWriteByte()
 147          {
 148   1              delayMS(1000);
 149   1      }
 150          
 151          void endReadByte()
 152          {
 153   1              delayMS(1000);
 154   1      }
 155          
 156          void disableDataProtection()
 157          {
 158   1              writeByte(0x5555, 0xaa);
 159   1              writeByte(0x2aaa, 0x55);
 160   1              writeByte(0x5555, 0x80);
 161   1              writeByte(0x5555, 0xaa);
 162   1              writeByte(0x2aaa, 0x55);
 163   1              writeByte(0x5555, 0x20);
 164   1      }
 165          
 166          void programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 167          {
 168   1              int i;
 169   1              unsigned char d;
 170   1              unsigned char failed = 0;
 171   1              unsigned char t = 0;
 172   1      
 173   1              beginWriteByte();
 174   1              disableDataProtection();
 175   1      
 176   1              beginWriteByte();
 177   1              for(i=0; i<size; i++)
 178   1              {
 179   2                      writeByte(startAddress+i, dat[i]);
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 4   

 180   2              }
 181   1              endWriteByte();
 182   1              
 183   1              delayMS(100);   
 184   1      }
*** WARNING C280 IN LINE 169 OF MAIN.C: 'd': unreferenced local variable
 185          
 186          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 187          {
 188   1              int i;
 189   1              unsigned char d;
 190   1              unsigned char failed = 0;
 191   1              unsigned char t = 0;
 192   1      
 193   1              beginReadByte();
 194   1              for(i=0; i<size; i++)
 195   1              {
 196   2                      d = readByte(startAddress+i);
 197   2                      if(d!=dat[i])
 198   2                              return 0;
 199   2              }
 200   1              endReadByte();
 201   1              
 202   1              return -1;
 203   1      }
 204          
 205          unsigned long int convertToBigEndian32(unsigned long int v)
 206          {
 207   1              return ((v>>24) & 0x000000ff) | ((v>>8) & 0x0000ff00) | ((v<<8) & 0x00ff0000) | ((v<<24) & 0xff00000);
 208   1      }
 209          
 210          code char temp[] = {
 211                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 212                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 213                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 214                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 215          
 216                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 217                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 218                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 219                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 220                                                  };
 221          
 222          void main()
 223          {
 224   1              State state = INITIAL;
 225   1              char* rxBuffer = 0;
 226   1              char test = 0;
 227   1              
 228   1              programPage(0, temp, 128);
 229   1              test = verifyPage(0, temp, 128);
 230   1              while(1)
 231   1              {
 232   2                      if(!test)
 233   2                      {
 234   3                              delayMS(250);
 235   3                              EEPROM_CE      = ~EEPROM_CE;
 236   3                      }
 237   2                      else
 238   2                      {
 239   3                              EEPROM_CE      = 0;
 240   3                      }
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 5   

 241   2              };
 242   1      
 243   1              #if 0
                      while(1)
                      {
                              switch(state)
                              {
                                      case INITIAL:
                                      {
                                              displayState(state);                            
                                              serialInitialize(9600);
                                              state = CONNECTING;
                                      }
                                      break;
              
                                      case CONNECTING:
                                      {
                                              displayState(state);                            
                                              rxBuffer = serialReceiveData(1, 500); // wait for command C
              
                                              //CONNECTED_LED = ~CONNECTED_LED;
                                              if(*rxBuffer == 'C')
                                              {
                                                      serialSendData("c", 1, 500); // ack
                                                      
                                                      state = CONNECTED;       // connected
                                              }
                                              else
                                              {
                                                      state = INITIAL;        // set next baud
                                              }                               
                                      }
                                      break;
                                              
                                      case CONNECTED:
                                      {
                                              displayState(state);                            
                                              // CONNECTED_LED = 1;           
                                      
                                              rxBuffer = serialReceiveData(1, -1); // wait for command P or V
                                              if(*rxBuffer == 'P')
                                              {
                                                      serialSendData("p", 1, 500);     // ack
                                                      
                                                      displayState(PROGRAM_EEPROM_PAGE);
                                                      
                                                      state = PROGRAM_EEPROM_PAGE;     // program
                                              }
                                              else if(*rxBuffer == 'V')
                                              {
                                                      serialSendData("v", 1, 500);     // ack
                                                      
                                                      displayState(VERIFY_EEPROM_PAGE);
                                                      
                                                      state = VERIFY_EEPROM_PAGE;      // verify
                                              }       
                                              else if(*rxBuffer == 'D')
                                              {
                                                      serialSendData('d', 1, 500);     // ack
                                                      
                                                      state = DONE;    // verify
                                              }                                       
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 6   

                                              else
                                              {
                                                      state = CONNECTED; // unknown command, again
                                              }
                                      }
                                      break;
                                              
                                      case PROGRAM_EEPROM_PAGE:
                                      {
                                              unsigned long int address;
                                              unsigned long int size;
                                              
                                              rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
                                              if(*rxBuffer == 'P')
                                              {
                                                      address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
                                                      size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
                                                      /*
                                                      displayState(1);                                         
              
                                                      sprintf(rxBuffer, "a:%lx", address);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      displayState(2);
                                                      
                                                      sprintf(rxBuffer, "s:%lx", size);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      displayState(3);                                        
                                                      
                                                      serialReceiveData(size, -1); // wait for command P or V
                                                      displayState(4);
                                                      
                                                      //serialSendData(rxBuffer, 16, -1);      // ack success
                                                      displayState(5);
                                                      */
                                                      
                                                      sprintf(rxBuffer, "a:%lx", address);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      
                                                      sprintf(rxBuffer, "s:%lx", size);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      
                                                      //PROGRAM_LED     = 1;
                                                      rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
                                                      programPage(address, rxBuffer, size);
                                                      if(verifyPage(address, rxBuffer, size))
                                                      {
                                                              //PROGRAM_LED     = 0;
                                                      
                                                              serialSendData("s", 1, -1);      // ack success
                                                              
                                                              state = DONE; // unknown command, again
                                                      }
                                                      else
                                                      {
                                                              //PROGRAM_LED     = 0;
                                                      
                                                              serialSendData("f", 1, -1);      // ack failed
                                                              
                                                              state = FAILED; // unknown command, again
                                                      }
                                              }
                                              else
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 7   

                                              {
                                                      serialSendData("f", 1, -1);      // ack failed
                                                              
                                                      state = FAILED; // unknown command, again
                                              }
                                      }
                                      break;
                                      
                                      case VERIFY_EEPROM_PAGE:
                                      {
                                              unsigned long int address;
                                              unsigned long int size;
                                              
                                              rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
                                              if(*rxBuffer == 'P')
                                              {
                                                      address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
                                                      size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
                                                      /*
                                                      displayState(1);                                         
              
                                                      sprintf(rxBuffer, "a:%lx", address);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      displayState(2);
                                                      
                                                      sprintf(rxBuffer, "s:%lx", size);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      displayState(3);                                        
                                                      
                                                      serialReceiveData(size, -1); // wait for command P or V
                                                      displayState(4);
                                                      
                                                      //serialSendData(rxBuffer, 16, -1);      // ack success
                                                      displayState(5);
                                                      */
                                                      
                                                      sprintf(rxBuffer, "a:%lx", address);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      
                                                      sprintf(rxBuffer, "s:%lx", size);
                                                      serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
                                                      
                                                      //PROGRAM_LED     = 1;
                                                      rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
                                                      if(verifyPage(address, rxBuffer, size))
                                                      {
                                                              //PROGRAM_LED     = 0;
                                                      
                                                              serialSendData("s", 1, -1);      // ack success
                                                              
                                                              state = DONE; // unknown command, again
                                                      }
                                                      else
                                                      {
                                                              //PROGRAM_LED     = 0;
                                                      
                                                              serialSendData("f", 1, -1);      // ack failed
                                                              
                                                              state = FAILED; // unknown command, again
                                                      }
                                              }
                                              else
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 17:18:14 PAGE 8   

                                              {
                                                      serialSendData("f", 1, -1);      // ack failed
                                                              
                                                      state = FAILED; // unknown command, again
                                              }
                                              
                                      }
                                      break;
                                      
                                      case FAILED:
                                      {
                                              delayMS(250);
                                              EEPROM_CE      = ~EEPROM_CE;
                                      }
                                      break;
                                      
                                      case DONE:
                                      {
                                              EEPROM_CE      = 0;
                                      }
                                      break;
                              }
                      }
                      
                      #endif
 452   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    656    ----
   CONSTANT SIZE    =     64    ----
   XDATA SIZE       =   ----      33
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
