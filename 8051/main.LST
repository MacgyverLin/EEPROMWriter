C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c COMPACT ROM(SMALL) OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          #include <string.h>
   6          
   7          typedef enum
   8          {
   9                  INITIAL = 0,
  10                  CONNECTING,
  11                  CONNECTED,
  12                  PROGRAM_EEPROM_PAGE,
  13                  VERIFY_EEPROM_PAGE,
  14                  FAILED,
  15                  DONE
  16          }State;
  17          
  18          sbit CONNECTED_LED   = P3^2;
  19          sbit PROGRAM_LED     = P3^3;
  20          sbit VERIFY_LED      = P3^4;
  21          
  22          void displayState(int state)
  23          {                                       
  24   1              CONNECTED_LED = (state & 0x01) ? 0 : 1;
  25   1              PROGRAM_LED = (state & 0x02) ? 0 : 1;
  26   1              VERIFY_LED = (state & 0x04) ? 0 : 1;
  27   1      }
  28          
  29          ////////////////////////////////////////////////////////////////////
  30          #define EEPROM_ADDRESS_L P0
  31          #define EEPROM_ADDRESS_H P1
  32          #define EEPROM_DATA P2
  33          
  34          sbit EEPROM_WR     = P3^7;
  35          sbit EEPROM_OE     = P3^6;
  36          sbit EEPROM_CE     = P3^5;
  37          
  38          #define SET_WR()                                        EEPROM_WR = 1
  39          #define SET_OE()                                        EEPROM_OE = 1
  40          #define SET_CE()                                        EEPROM_CE = 1
  41          #define CLR_WR()                                        EEPROM_WR = 0
  42          #define CLR_OE()                                        EEPROM_OE = 0
  43          #define CLR_CE()                                        EEPROM_CE = 0
  44          #define GET_WR()                                        EEPROM_WR
  45          #define GET_OE()                                        EEPROM_OE
  46          #define GET_CE()                                        EEPROM_CE
  47          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  48          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
  49          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  50          #define GET_EEPROM_DATA()                       EEPROM_DATA
  51          
  52          void setAddress(unsigned int addr)
  53          {
  54   1              SET_EEPROM_ADDRESS_L(addr & 0xff);
  55   1              SET_EEPROM_ADDRESS_H(addr >> 8);
C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 2   

  56   1      }
  57          
  58          void setData(unsigned char dat)
  59          {
  60   1              SET_EEPROM_DATA(dat);
  61   1      }
  62          
  63          unsigned char getData()
  64          {
  65   1              return GET_EEPROM_DATA();
  66   1      }
  67          
  68          void initEEPROWriter()
  69          {
  70   1              setAddress(0xffff);
  71   1              setData(0xff);
  72   1              SET_WR();
  73   1              SET_OE();
  74   1              SET_CE();
  75   1              
  76   1              delayMS(100);
  77   1      }
  78          
  79          void beginWriteByte()
  80          {
  81   1              setAddress(0xffff);
  82   1              setData(0xff);
  83   1      
  84   1              SET_WR();
  85   1              delay1us();
  86   1              SET_OE();
  87   1              delay1us();
  88   1              CLR_CE();
  89   1              delay1us();
  90   1      }
  91          
  92          void writeByte(unsigned int address, unsigned char dat)
  93          {
  94   1              setAddress(address);
  95   1              setData(dat);
  96   1      
  97   1              //CLR_CE();
  98   1              //delay1us();
  99   1              CLR_WR();
 100   1              delay1us();
 101   1      
 102   1              //SET_CE();
 103   1              //delay1us();
 104   1              SET_WR();
 105   1              delay1us();
 106   1      }
 107           
 108          void endWriteByte()
 109          {
 110   1              SET_CE();
 111   1              delayMS(100);
 112   1      }
 113          
 114          void beginReadByte()
 115          {
 116   1              setAddress(0xffff);
 117   1              setData(0xff);
C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 3   

 118   1      
 119   1              SET_WR();
 120   1              delay1us();
 121   1              SET_OE();
 122   1              delay1us();
 123   1              CLR_CE();
 124   1              delay1us();
 125   1      }
 126          
 127          unsigned char readByte(unsigned int address)
 128          {
 129   1              unsigned char dat;
 130   1      
 131   1              setAddress(address);
 132   1              setData(0xff);
 133   1      
 134   1              //CLR_CE();
 135   1              CLR_OE();
 136   1              delay1us();
 137   1      
 138   1              dat = getData();
 139   1      
 140   1              //SET_CE();
 141   1              SET_OE();
 142   1              delay1us();
 143   1      
 144   1              return dat;
 145   1      }
 146          
 147          void endReadByte()
 148          {
 149   1              SET_CE();
 150   1              delayMS(100);
 151   1      }
 152          
 153          void enableDataProtection()
 154          {
 155   1              writeByte(0x5555, 0xaa);
 156   1              writeByte(0x2aaa, 0x55);
 157   1              writeByte(0x5555, 0xa0);
 158   1      }
 159          
 160          void disableDataProtection()
 161          {
 162   1              writeByte(0x5555, 0xaa);
 163   1              writeByte(0x2aaa, 0x55);
 164   1              writeByte(0x5555, 0x80);
 165   1              writeByte(0x5555, 0xaa);
 166   1              writeByte(0x2aaa, 0x55);
 167   1              writeByte(0x5555, 0x20);
 168   1      }
 169          
 170          void programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 171          {
 172   1              int i;
 173   1              unsigned char d;
 174   1              unsigned char failed = 0;
 175   1              unsigned char t = 0;
 176   1      
 177   1              beginWriteByte();
 178   1              disableDataProtection();
 179   1              //endWriteByte();
C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 4   

 180   1      
 181   1              //beginWriteByte();
 182   1              for(i=0; i<size; i++)
 183   1              {
 184   2                      writeByte(startAddress+i, dat[i]);
 185   2              }
 186   1              endWriteByte(); 
 187   1      }
*** WARNING C280 IN LINE 173 OF MAIN.C: 'd': unreferenced local variable
 188          
 189          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 190          {
 191   1              int i;
 192   1              unsigned char d;
 193   1              unsigned char failed = 0;
 194   1              unsigned char t = 0;
 195   1      
 196   1              beginReadByte();
 197   1              for(i=0; i<size; i++)
 198   1              {
 199   2                      d = readByte(startAddress+i);
 200   2                      //serialSendData(&d, 1, 500); // ack
 201   2                              
 202   2                      if(d!=dat[i])
 203   2                              return 0;
 204   2              }
 205   1              endReadByte();
 206   1              
 207   1              return -1;
 208   1      }
 209          
 210          unsigned long int convertToBigEndian32(unsigned long int v)
 211          {
 212   1              return ((v>>24) & 0x000000ff) | ((v>>8) & 0x0000ff00) | ((v<<8) & 0x00ff0000) | ((v<<24) & 0xff00000);
 213   1      }
 214          
 215          code unsigned char temp[] = {
 216                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 217                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 218                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 219                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 220                                                  };
 221          
 222          void main()
 223          {
 224   1              #if 0
                      char test = 0;
                      serialInitialize(9600);
              
                      programPage(0, temp, 32);
                      test = verifyPage(0, temp, 32);
                      while(1)
                      {
                              if(!test)
                              {
                                      delayMS(250);
                                      EEPROM_CE      = ~EEPROM_CE;
                              }
                              else
                              {
                                      EEPROM_CE      = 0;
                              }
C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 5   

                      };
                      #else
 243   1              State state = INITIAL;
 244   1              char* rxBuffer = 0;
 245   1      
 246   1              while(1)
 247   1              {
 248   2                      switch(state)
 249   2                      {
 250   3                              case INITIAL:
 251   3                              {
 252   4                                      displayState(state);                            
 253   4                                      serialInitialize(9600);
 254   4                                      state = CONNECTING;
 255   4                              }
 256   3                              break;
 257   3      
 258   3                              case CONNECTING:
 259   3                              {
 260   4                                      displayState(state);                            
 261   4                                      rxBuffer = serialReceiveData(1, -1); // wait for command C
 262   4      
 263   4                                      //CONNECTED_LED = ~CONNECTED_LED;
 264   4                                      if(*rxBuffer == 'C') 
 265   4                                      {
 266   5                                              serialSendData("c", 1, -1); // ack
 267   5                                              
 268   5                                              state = CONNECTED;       // connected
 269   5                                      }
 270   4                                      else
 271   4                                      {
 272   5                                              state = INITIAL;        // set next baud
 273   5                                      }                               
 274   4                              }
 275   3                              break;
 276   3                                      
 277   3                              case CONNECTED:
 278   3                              {
 279   4                                      displayState(state);                            
 280   4                                      // CONNECTED_LED = 1;           
 281   4                              
 282   4                                      rxBuffer = serialReceiveData(1, -1); // wait for command P or V
 283   4                                      if(*rxBuffer == 'P')
 284   4                                      {
 285   5                                              serialSendData("p", 1, 500);     // ack
 286   5                                              
 287   5                                              state = PROGRAM_EEPROM_PAGE;     // program
 288   5                                      }
 289   4                                      else if(*rxBuffer == 'V')
 290   4                                      {
 291   5                                              serialSendData("v", 1, 500);     // ack
 292   5                                              
 293   5                                              state = VERIFY_EEPROM_PAGE;      // verify
 294   5                                      }       
 295   4                                      else if(*rxBuffer == 'D')
 296   4                                      {
 297   5                                              serialSendData('d', 1, 500);     // ack
 298   5                                              
 299   5                                              state = DONE;    // verify
 300   5                                      }                                       
 301   4                                      else
 302   4                                      {
C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 6   

 303   5                                              state = CONNECTED; // unknown command, again
 304   5                                      }
 305   4                              }
 306   3                              break;
 307   3                                      
 308   3                              case PROGRAM_EEPROM_PAGE:
 309   3                              {
 310   4                                      unsigned long int address;
 311   4                                      unsigned long int size;
 312   4                                      
 313   4                                      displayState(state);
 314   4                                      
 315   4                                      rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
 316   4                                      if(*rxBuffer == 'D')
 317   4                                      {
 318   5                                              serialSendData("d", 1, -1);      // ack failed
 319   5                                                      
 320   5                                              state = DONE; // unknown command, again
 321   5                                      }                               
 322   4                                      else if(*rxBuffer == 'A')
 323   4                                      {
 324   5                                              address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
 325   5                                              size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
 326   5      
 327   5                                              serialSendData("a", 1, -1);
 328   5      
 329   5                                              //PROGRAM_LED     = 1;
 330   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
 331   5                                              programPage(address, rxBuffer, size);
 332   5                                              if(verifyPage(address, rxBuffer, size))
 333   5                                              {
 334   6                                                      //PROGRAM_LED     = 0;
 335   6                                              
 336   6                                                      serialSendData("s", 1, -1);      // ack success
 337   6      
 338   6                                                      state = PROGRAM_EEPROM_PAGE; // unknown command, again
 339   6                                              }
 340   5                                              else
 341   5                                              {
 342   6                                                      //PROGRAM_LED     = 0;
 343   6                                              
 344   6                                                      serialSendData("f", 1, -1);      // ack failed
 345   6                                                      
 346   6                                                      state = FAILED; // unknown command, again
 347   6                                              }
 348   5                                      }
 349   4                                      else
 350   4                                      {
 351   5                                              serialSendData("f", 1, -1);      // ack failed
 352   5                                                      
 353   5                                              state = FAILED; // unknown command, again
 354   5                                      }
 355   4                              }
 356   3                              break;
 357   3                              
 358   3                              case VERIFY_EEPROM_PAGE:
 359   3                              {
 360   4                                      unsigned long int address;
 361   4                                      unsigned long int size;
 362   4                                      
 363   4                                      displayState(state);
 364   4                                      
C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 7   

 365   4                                      rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
 366   4                                      if(*rxBuffer == 'D')
 367   4                                      {
 368   5                                              serialSendData("d", 1, -1);      // ack failed
 369   5                                                      
 370   5                                              state = DONE; // unknown command, again
 371   5                                      }                               
 372   4                                      else if(*rxBuffer == 'A')
 373   4                                      {
 374   5                                              address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
 375   5                                              size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
 376   5                                              
 377   5                                              serialSendData("a", 1, -1);
 378   5      
 379   5                                              //PROGRAM_LED     = 1;
 380   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
 381   5                                              //programPage(address, rxBuffer, size);
 382   5                                              if(verifyPage(address, rxBuffer, size))
 383   5                                              {
 384   6                                                      //PROGRAM_LED     = 0;
 385   6                                              
 386   6                                                      serialSendData("s", 1, -1);      // ack success
 387   6      
 388   6                                                      state = VERIFY_EEPROM_PAGE; // unknown command, again
 389   6                                              }
 390   5                                              else
 391   5                                              {
 392   6                                                      //PROGRAM_LED     = 0;
 393   6                                              
 394   6                                                      serialSendData("f", 1, -1);      // ack failed
 395   6                                                      
 396   6                                                      state = FAILED; // unknown command, again
 397   6                                              }
 398   5                                      }
 399   4                                      else
 400   4                                      {
 401   5                                              serialSendData("f", 1, -1);      // ack failed
 402   5                                                      
 403   5                                              state = FAILED; // unknown command, again
 404   5                                      }
 405   4                              }
 406   3                              break;
 407   3                              
 408   3                              case FAILED:
 409   3                              {       
 410   4                                      displayState(state);
 411   4                              }
 412   3                              break;
 413   3                              
 414   3                              case DONE:
 415   3                              {
 416   4                                      displayState(state);
 417   4                              }
 418   3                              break;
 419   3                      }
 420   2              }
 421   1              
 422   1              #endif
 423   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.01   MAIN                                                                  03/02/2019 08:42:48 PAGE 8   

   CODE SIZE        =    976    ----
   CONSTANT SIZE    =     46    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      40
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
