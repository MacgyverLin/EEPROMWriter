C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          #include <string.h>
   6          
   7          typedef enum
   8          {
   9                  INITIAL = 0,
  10                  CONNECTING,
  11                  CONNECTED,
  12                  PROGRAM_EEPROM_PAGE,
  13                  VERIFY_EEPROM_PAGE,
  14                  FAILED,
  15                  DONE
  16          }State;
  17          
  18          sbit CONNECTED_LED   = P3^2;
  19          sbit PROGRAM_LED     = P3^3;
  20          sbit VERIFY_LED      = P3^4;
  21          
  22          void displayState(int state)
  23          {                                       
  24   1              CONNECTED_LED = (state & 0x01) ? 0 : 1;
  25   1              PROGRAM_LED = (state & 0x02) ? 0 : 1;
  26   1              VERIFY_LED = (state & 0x04) ? 0 : 1;
  27   1      }
  28          
  29          void delay()
  30          {
  31   1              unsigned int i = 0;
  32   1      
  33   1              while(i++<10000);
  34   1      }
  35          
  36          ////////////////////////////////////////////////////////////////////
  37          #define EEPROM_ADDRESS_L P0
  38          #define EEPROM_ADDRESS_H P1
  39          #define EEPROM_DATA P2
  40          
  41          sbit EEPROM_WR     = P3^7;
  42          sbit EEPROM_OE     = P3^6;
  43          sbit EEPROM_CE     = P3^5;
  44          
  45          #define SET_WR()                                        EEPROM_WR = 1
  46          #define SET_OE()                                        EEPROM_OE = 1
  47          #define SET_CE()                                        EEPROM_CE = 1
  48          #define CLR_WR()                                        EEPROM_WR = 0
  49          #define CLR_OE()                                        EEPROM_OE = 0
  50          #define CLR_CE()                                        EEPROM_CE = 0
  51          #define GET_WR()                                        EEPROM_WR
  52          #define GET_OE()                                        EEPROM_OE
  53          #define GET_CE()                                        EEPROM_CE
  54          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  55          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 2   

  56          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  57          #define GET_EEPROM_DATA()                       EEPROM_DATA
  58          
  59          void setAddress(unsigned int addr)
  60          {
  61   1              SET_EEPROM_ADDRESS_L(addr & 0xff);
  62   1              SET_EEPROM_ADDRESS_H(addr >> 8);
  63   1      }
  64          
  65          void setData(unsigned char dat)
  66          {
  67   1              SET_EEPROM_DATA(dat);
  68   1      }
  69          
  70          unsigned char getData()
  71          {
  72   1              return GET_EEPROM_DATA();
  73   1      }
  74          
  75          void initEEPROWriter()
  76          {
  77   1              setAddress(0xffff);
  78   1              setData(0xff);
  79   1              SET_WR();
  80   1              SET_OE();
  81   1              SET_CE();
  82   1              
  83   1              delayMS(10);
  84   1      }
  85          
  86          void beginWriteByte()
  87          {
  88   1              setAddress(0xffff);
  89   1              setData(0xff);
  90   1              SET_WR();
  91   1              SET_OE();
  92   1              SET_CE();
  93   1      }
  94          
  95          void writeByte(unsigned int address, unsigned char dat)
  96          {
  97   1              setAddress(address);
  98   1              setData(dat);
  99   1              delay1us();
 100   1      
 101   1              CLR_CE();
 102   1              delay1us();
 103   1              CLR_WR();
 104   1              delay1us();
 105   1      
 106   1              SET_CE();
 107   1              delay1us();
 108   1              SET_WR();
 109   1              delay1us();
 110   1      }
 111          
 112          void beginReadByte()
 113          {
 114   1              setAddress(0xffff);
 115   1              setData(0xff);
 116   1              delay1us();
 117   1      
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 3   

 118   1              SET_CE();
 119   1              SET_WR();
 120   1              SET_OE();
 121   1      }
 122          
 123          unsigned char readByte(unsigned int address)
 124          {
 125   1              unsigned char dat;
 126   1      
 127   1              setAddress(address);
 128   1              delay1us();
 129   1      
 130   1              CLR_CE();
 131   1              delay1us();
 132   1              CLR_OE();
 133   1              delay1us();
 134   1      
 135   1              dat = getData();
 136   1              delay1us();
 137   1      
 138   1              SET_CE();
 139   1              delay1us();
 140   1              SET_OE();
 141   1              delay1us();
 142   1      
 143   1              return dat;
 144   1      }
 145          
 146          void endWriteByte()
 147          {
 148   1              delayMS(1000);
 149   1      }
 150          
 151          void endReadByte()
 152          {
 153   1              delayMS(1000);
 154   1      }
 155          
 156          void disableDataProtection()
 157          {
 158   1              writeByte(0x5555, 0xaa);
 159   1              writeByte(0x2aaa, 0x55);
 160   1              writeByte(0x5555, 0x80);
 161   1              writeByte(0x5555, 0xaa);
 162   1              writeByte(0x2aaa, 0x55);
 163   1              writeByte(0x5555, 0x20);
 164   1      }
 165          
 166          void programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 167          {
 168   1              int i;
 169   1              unsigned char d;
 170   1              unsigned char failed = 0;
 171   1              unsigned char t = 0;
 172   1      
 173   1              beginWriteByte();
 174   1              disableDataProtection();
 175   1      
 176   1              beginWriteByte();
 177   1              for(i=0; i<size; i++)
 178   1              {
 179   2                      writeByte(startAddress+i, dat[i]);
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 4   

 180   2              }
 181   1              endWriteByte();
 182   1              
 183   1              delayMS(100);   
 184   1      }
*** WARNING C280 IN LINE 169 OF MAIN.C: 'd': unreferenced local variable
 185          
 186          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 187          {
 188   1              int i;
 189   1              unsigned char d;
 190   1              unsigned char failed = 0;
 191   1              unsigned char t = 0;
 192   1      
 193   1              beginReadByte();
 194   1              for(i=0; i<size; i++)
 195   1              {
 196   2                      d = readByte(startAddress+i);
 197   2                      if(d!=dat[i])
 198   2                              return 0;
 199   2              }
 200   1              endReadByte();
 201   1              
 202   1              return -1;
 203   1      }
 204          
 205          unsigned long int convertToBigEndian32(unsigned long int v)
 206          {
 207   1              return ((v>>24) & 0x000000ff) | ((v>>8) & 0x0000ff00) | ((v<<8) & 0x00ff0000) | ((v<<24) & 0xff00000);
 208   1      }
 209          
 210          code char temp[] = {
 211                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 212                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 213                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 214                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 215          
 216                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 217                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 218                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 219                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 220                  
 221                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 222                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 223                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 224                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 225          
 226                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 227                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 228                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 229                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
 230                                                  };
 231          
 232          void main()
 233          {
 234   1              #if 0
                      char test = 0;
                      programPage(0, temp, 128);
                      test = verifyPage(0, temp, 128);
                      while(1)
                      {
                              if(!test)
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 5   

                              {
                                      delayMS(250);
                                      EEPROM_CE      = ~EEPROM_CE;
                              }
                              else
                              {
                                      EEPROM_CE      = 0;
                              }
                      };
                      #else
 251   1              State state = INITIAL;
 252   1              char* rxBuffer = 0;
 253   1      
 254   1              while(1)
 255   1              {
 256   2                      switch(state)
 257   2                      {
 258   3                              case INITIAL:
 259   3                              {
 260   4                                      displayState(state);                            
 261   4                                      serialInitialize(9600);
 262   4                                      state = CONNECTING;
 263   4                              }
 264   3                              break;
 265   3      
 266   3                              case CONNECTING:
 267   3                              {
 268   4                                      displayState(state);                            
 269   4                                      rxBuffer = serialReceiveData(1, -1); // wait for command C
 270   4      
 271   4                                      //CONNECTED_LED = ~CONNECTED_LED;
 272   4                                      if(*rxBuffer == 'C') 
 273   4                                      {
 274   5                                              serialSendData("c", 1, 500); // ack
 275   5                                              
 276   5                                              state = CONNECTED;       // connected
 277   5                                      }
 278   4                                      else
 279   4                                      {
 280   5                                              state = INITIAL;        // set next baud
 281   5                                      }                               
 282   4                              }
 283   3                              break;
 284   3                                      
 285   3                              case CONNECTED:
 286   3                              {
 287   4                                      displayState(state);                            
 288   4                                      // CONNECTED_LED = 1;           
 289   4                              
 290   4                                      rxBuffer = serialReceiveData(1, -1); // wait for command P or V
 291   4                                      if(*rxBuffer == 'P')
 292   4                                      {
 293   5                                              serialSendData("p", 1, 500);     // ack
 294   5                                              
 295   5                                              state = PROGRAM_EEPROM_PAGE;     // program
 296   5                                      }
 297   4                                      else if(*rxBuffer == 'V')
 298   4                                      {
 299   5                                              serialSendData("v", 1, 500);     // ack
 300   5                                              
 301   5                                              state = VERIFY_EEPROM_PAGE;      // verify
 302   5                                      }       
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 6   

 303   4                                      else if(*rxBuffer == 'D')
 304   4                                      {
 305   5                                              serialSendData('d', 1, 500);     // ack
 306   5                                              
 307   5                                              state = DONE;    // verify
 308   5                                      }                                       
 309   4                                      else
 310   4                                      {
 311   5                                              state = CONNECTED; // unknown command, again
 312   5                                      }
 313   4                              }
 314   3                              break;
 315   3                                      
 316   3                              case PROGRAM_EEPROM_PAGE:
 317   3                              {
 318   4                                      unsigned long int address;
 319   4                                      unsigned long int size;
 320   4                                      
 321   4                                      displayState(state);
 322   4                                      
 323   4                                      rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
 324   4                                      if(*rxBuffer == 'D')
 325   4                                      {
 326   5                                              serialSendData("d", 1, -1);      // ack failed
 327   5                                                      
 328   5                                              state = FAILED; // unknown command, again
 329   5                                      }                               
 330   4                                      else if(*rxBuffer == 'P')
 331   4                                      {
 332   5                                              address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
 333   5                                              size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
 334   5                                              
 335   5                                              //PROGRAM_LED     = 1;
 336   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
 337   5                                              programPage(address, rxBuffer, size);
 338   5                                              if(verifyPage(address, rxBuffer, size))
 339   5                                              {
 340   6                                                      //PROGRAM_LED     = 0;
 341   6                                              
 342   6                                                      serialSendData("s", 1, -1);      // ack success
 343   6      
 344   6                                                      state = DONE; // unknown command, again
 345   6                                              }
 346   5                                              else
 347   5                                              {
 348   6                                                      //PROGRAM_LED     = 0;
 349   6                                              
 350   6                                                      serialSendData("f", 1, -1);      // ack failed
 351   6                                                      
 352   6                                                      state = FAILED; // unknown command, again
 353   6                                              }
 354   5                                      }
 355   4                                      else
 356   4                                      {
 357   5                                              serialSendData("f", 1, -1);      // ack failed
 358   5                                                      
 359   5                                              state = FAILED; // unknown command, again
 360   5                                      }
 361   4                              }
 362   3                              break;
 363   3                              
 364   3                              case VERIFY_EEPROM_PAGE:
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 7   

 365   3                              {
 366   4                                      unsigned long int address;
 367   4                                      unsigned long int size;
 368   4                                      
 369   4                                      displayState(state);
 370   4                                      
 371   4                                      rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
 372   4                                      if(*rxBuffer == 'D')
 373   4                                      {
 374   5                                              serialSendData("d", 1, -1);      // ack failed
 375   5                                                      
 376   5                                              state = FAILED; // unknown command, again
 377   5                                      }                               
 378   4                                      else if(*rxBuffer == 'V')
 379   4                                      {
 380   5                                              address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
 381   5                                              size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
 382   5                                              
 383   5                                              //PROGRAM_LED     = 1;
 384   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
 385   5                                              //programPage(address, rxBuffer, size);
 386   5                                              if(verifyPage(address, rxBuffer, size))
 387   5                                              {
 388   6                                                      //PROGRAM_LED     = 0;
 389   6                                              
 390   6                                                      serialSendData("s", 1, -1);      // ack success
 391   6      
 392   6                                                      state = DONE; // unknown command, again
 393   6                                              }
 394   5                                              else
 395   5                                              {
 396   6                                                      //PROGRAM_LED     = 0;
 397   6                                              
 398   6                                                      serialSendData("f", 1, -1);      // ack failed
 399   6                                                      
 400   6                                                      state = FAILED; // unknown command, again
 401   6                                              }
 402   5                                      }
 403   4                                      else
 404   4                                      {
 405   5                                              serialSendData("f", 1, -1);      // ack failed
 406   5                                                      
 407   5                                              state = FAILED; // unknown command, again
 408   5                                      }
 409   4                              }
 410   3                              break;
 411   3                              
 412   3                              case FAILED:
 413   3                              {
 414   4                                      delayMS(250);
 415   4                                      EEPROM_CE      = ~EEPROM_CE;
 416   4                              }
 417   3                              break;
 418   3                              
 419   3                              case DONE:
 420   3                              {
 421   4                                      EEPROM_CE      = 0;
 422   4                              }
 423   3                              break;
 424   3                      }
 425   2              }
 426   1              
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 21:31:51 PAGE 8   

 427   1              #endif
 428   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1116    ----
   CONSTANT SIZE    =    140    ----
   XDATA SIZE       =   ----      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
