C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:29:42 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(9,SIZE) REGFILE(.\template.ORC) BROWSE D
                    -EBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          
   6          typedef enum
   7          {
   8                  INITIAL = 0,
   9                  CONNECTING,
  10                  CONNECTED,
  11                  PROGRAM_EEPROM_PAGE,
  12                  VERIFY_EEPROM_PAGE,
  13                  FAILED,
  14                  DONE
  15          }State;
  16          
  17          sbit CONNECTED_LED   = P3^0;
  18          sbit PROGRAM_LED     = P3^1;
  19          sbit VERIFY_LED      = P3^2;
  20          
  21          
  22          ////////////////////////////////////////////////////////////////////
  23          #define EEPROM_ADDRESS_L P0
  24          #define EEPROM_ADDRESS_H P1
  25          #define EEPROM_DATA P2
  26          
  27          sbit EEPROM_WR     = P3^7;
  28          sbit EEPROM_OE     = P3^6;
  29          sbit EEPROM_CE     = P3^5;
  30          
  31          #define SET_WR()                                        EEPROM_WR = 1
  32          #define SET_OE()                                        EEPROM_OE = 1
  33          #define SET_CE()                                        EEPROM_CE = 1
  34          #define CLR_WR()                                        EEPROM_WR = 0
  35          #define CLR_OE()                                        EEPROM_OE = 0
  36          #define CLR_CE()                                        EEPROM_CE = 0
  37          #define GET_WR()                                        EEPROM_WR
  38          #define GET_OE()                                        EEPROM_OE
  39          #define GET_CE()                                        EEPROM_CE
  40          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  41          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
  42          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  43          #define GET_EEPROM_DATA()                       EEPROM_DATA
  44          
  45          void setAddress(unsigned int addr)
  46          {
  47   1              SET_EEPROM_ADDRESS_L(addr & 0xff);
  48   1              SET_EEPROM_ADDRESS_H(addr >> 8);
  49   1      }
  50          
  51          void setData(unsigned char dat)
  52          {
  53   1              SET_EEPROM_DATA(dat);
  54   1      }
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:29:42 PAGE 2   

  55          
  56          unsigned char getData()
  57          {
  58   1              return GET_EEPROM_DATA();
  59   1      }
  60          
  61          void initEEPROWriter()
  62          {
  63   1              setAddress(0xffff);
  64   1              setData(0xff);
  65   1              SET_WR();
  66   1              SET_OE();
  67   1              SET_CE();
  68   1              
  69   1              delayMS(10);
  70   1      }
  71          
  72          void beginWriteByte()
  73          {
  74   1              setAddress(0xffff);
  75   1              setData(0xff);
  76   1              SET_WR();
  77   1              SET_OE();
  78   1              SET_CE();
  79   1      }
  80          
  81          void writeByte(unsigned int address, unsigned char dat)
  82          {
  83   1              setAddress(address);
  84   1              setData(dat);
  85   1              delay1us();
*** WARNING C206 IN LINE 85 OF MAIN.C: 'delay1us': missing function-prototype
  86   1      
  87   1              CLR_CE();
  88   1              delay1us();
  89   1              CLR_WR();
  90   1              delay1us();
  91   1      
  92   1              SET_CE();
  93   1              delay1us();
  94   1              SET_WR();
  95   1              delay1us();
  96   1      }
  97          
  98          void beginReadByte()
  99          {
 100   1              setAddress(0xffff);
 101   1              setData(0xff);
 102   1              delay1us();
 103   1      
 104   1              SET_CE();
 105   1              SET_WR();
 106   1              SET_OE();
 107   1      }
 108          
 109          unsigned char readByte(unsigned int address)
 110          {
 111   1              unsigned char dat;
 112   1      
 113   1              setAddress(address);
 114   1              delay1us();
 115   1      
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:29:42 PAGE 3   

 116   1              CLR_CE();
 117   1              delay1us();
 118   1              CLR_OE();
 119   1              delay1us();
 120   1      
 121   1              dat = getData();
 122   1              delay1us();
 123   1      
 124   1              SET_CE();
 125   1              delay1us();
 126   1              SET_OE();
 127   1              delay1us();
 128   1      
 129   1              return dat;
 130   1      }
 131          
 132          void endWriteByte()
 133          {
 134   1              delayMS(1000);
 135   1      }
 136          
 137          void endReadByte()
 138          {
 139   1              delayMS(1000);
 140   1      }
 141          
 142          void disableDataProtection()
 143          {
 144   1              writeByte(0x5555, 0xaa);
 145   1              writeByte(0x2aaa, 0x55);
 146   1              writeByte(0x5555, 0x80);
 147   1              writeByte(0x5555, 0xaa);
 148   1              writeByte(0x2aaa, 0x55);
 149   1              writeByte(0x5555, 0x20);
 150   1      }
 151          
 152          char programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 153          {
 154   1              int i;
 155   1              unsigned char d;
 156   1              unsigned char failed = 0;
 157   1              unsigned char t = 0;
 158   1      
 159   1              beginWriteByte();
 160   1              disableDataProtection();
 161   1      
 162   1              beginWriteByte();
 163   1              for(i=0; i<size; i++)
 164   1              {
 165   2                      writeByte(startAddress+i, dat[i]);
 166   2              }
 167   1              endWriteByte();
 168   1      
 169   1              beginReadByte();
 170   1              for(i=0; i<size; i++)
 171   1              {
 172   2                      d = readByte(startAddress+i);
 173   2                      if(d!=dat[i])
 174   2                              return 0;
 175   2              }
 176   1              endReadByte();
 177   1              
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:29:42 PAGE 4   

 178   1              return -1;
 179   1      }
 180          
 181          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 182          {
 183   1              int i;
 184   1              unsigned char d;
 185   1              unsigned char failed = 0;
 186   1              unsigned char t = 0;
 187   1      
 188   1              beginReadByte();
 189   1              for(i=0; i<size; i++)
 190   1              {
 191   2                      d = readByte(startAddress+i);
 192   2                      if(d!=dat[i])
 193   2                              return 0;
 194   2              }
 195   1              endReadByte();
 196   1              
 197   1              return -1;
 198   1      }
 199          
 200          void main()
 201          {
 202   1              int a = sizeof(unsigned int);
 203   1              int b = sizeof(unsigned long);
 204   1              
 205   1              State state = INITIAL;
 206   1              char rxBuffer[128];
 207   1              
 208   1              CONNECTED_LED   = 0;
 209   1              PROGRAM_LED     = 0;
 210   1              VERIFY_LED      = 0;
 211   1              
 212   1              while(1)
 213   1              {
 214   2                      switch(state)
 215   2                      {
 216   3                              case INITIAL:
 217   3                                      serialInitialize(9600);
 218   3                              
 219   3                                      state = CONNECTING;
 220   3                                      break;
 221   3      
 222   3                              case CONNECTING:
 223   3                              {
 224   4                                      serialReceiveData(rxBuffer, 1, 500); // wait for command C
 225   4      
 226   4                                      CONNECTED_LED = ~CONNECTED_LED;
 227   4                                      
 228   4                                      if(*rxBuffer == 'C')
 229   4                                      {
 230   5                                              serialSendData('c', 1, 500); // ack
 231   5                                              
 232   5                                              state = CONNECTED;       // connected
 233   5                                      }
 234   4                                      else
 235   4                                      {
 236   5                                              state = INITIAL;        // set next baud
 237   5                                      }                               
 238   4                              }
 239   3                              break;
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:29:42 PAGE 5   

 240   3                                      
 241   3                              case CONNECTED:
 242   3                              {
 243   4                                      CONNECTED_LED = 1;              
 244   4                              
 245   4                                      serialReceiveData(rxBuffer, 1, -1); // wait for command P or V
 246   4      
 247   4                                      if(*rxBuffer == 'P')
 248   4                                      {
 249   5                                              serialSendData('p', 1, 500);     // ack
 250   5                                              
 251   5                                              state = PROGRAM_EEPROM_PAGE;     // program
 252   5                                      }
 253   4                                      else if(*rxBuffer == 'V')
 254   4                                      {
 255   5                                              serialSendData('v', 1, 500);     // ack
 256   5                                              
 257   5                                              state = VERIFY_EEPROM_PAGE;      // verify
 258   5                                      }       
 259   4                                      else if(*rxBuffer == 'D')
 260   4                                      {
 261   5                                              serialSendData('d', 1, 500);     // ack
 262   5                                              
 263   5                                              state = DONE;    // verify
 264   5                                      }                                       
 265   4                                      else
 266   4                                      {
 267   5                                              state = CONNECTED; // unknown command, again
 268   5                                      }
 269   4                              }
 270   3                              break;
 271   3                                      
 272   3                              case PROGRAM_EEPROM_PAGE:
 273   3                              {
 274   4                                      unsigned long address;
 275   4                                      unsigned long size;
 276   4                                      
 277   4                                      serialReceiveData(rxBuffer, 1+4+4, -1); // wait for command P or V
 278   4                                      if(*rxBuffer == 'P')
 279   4                                      {
 280   5                                              address = *((unsigned long*)(rxBuffer+1));
 281   5                                              size    = *((unsigned long*)(rxBuffer+1+4));
 282   5                                              
 283   5                                              assert(size<=128);
 284   5                                              serialReceiveData(rxBuffer+1+4+4, size, -1); // wait for command P or V
 285   5                                              
 286   5                                              PROGRAM_LED     = 1;
 287   5                                              
 288   5                                              if(programPage(address, rxBuffer, size))
 289   5                                              {
 290   6                                                      PROGRAM_LED     = 0;
 291   6                                              
 292   6                                                      serialSendData('s', 1, -1);      // ack success
 293   6                                                      
 294   6                                                      state = CONNECTED; // unknown command, again
 295   6                                              }
 296   5                                              else
 297   5                                              {
 298   6                                                      PROGRAM_LED     = 0;
 299   6                                              
 300   6                                                      serialSendData('f', 1, -1);      // ack failed
 301   6                                                      
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:29:42 PAGE 6   

 302   6                                                      state = FAILED; // unknown command, again
 303   6                                              }
 304   5                                      }
 305   4                              }
 306   3                              break;
 307   3                              
 308   3                              case VERIFY_EEPROM_PAGE:
 309   3                              {
 310   4                                      unsigned long address;
 311   4                                      unsigned long size;
 312   4                                      
 313   4                                      serialReceiveData(rxBuffer, 1+4+4, -1); // wait for command P or V
 314   4                                      if(*rxBuffer == 'S')
 315   4                                      {
 316   5                                              address = *((unsigned long*)(rxBuffer+1));
 317   5                                              size    = *((unsigned long*)(rxBuffer+1+4));
 318   5                                              
 319   5                                              assert(size<=128);
 320   5                                              serialReceiveData(rxBuffer+1+4+4, size, -1); // wait for command P or V
 321   5                                              
 322   5                                              VERIFY_LED     = 1;
 323   5                                              
 324   5                                              if(verifyPage(address, rxBuffer, size))
 325   5                                              {
 326   6                                                      VERIFY_LED     = 0;
 327   6                                              
 328   6                                                      serialSendData('s', 1, -1);      // ack success
 329   6      
 330   6                                                      state = CONNECTED;
 331   6                                              }
 332   5                                              else
 333   5                                              {
 334   6                                                      VERIFY_LED     = 0;
 335   6                                              
 336   6                                                      serialSendData('f', 1, -1);      // ack failed  
 337   6                                                      
 338   6                                                      state = FAILED;
 339   6                                              }                                       
 340   5                                      }
 341   4                              }
 342   3                              break;
 343   3                              
 344   3                              case FAILED:
 345   3                              {
 346   4                                      VERIFY_LED      = VERIFY_LED;
 347   4                              }
 348   3                              break;
 349   3                              
 350   3                              case DONE:
 351   3                              {
 352   4                                      VERIFY_LED      = 1;
 353   4                              }
 354   3                              break;
 355   3                      }
 356   2              }
 357   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1020    ----
   CONSTANT SIZE    =     51    ----
   XDATA SIZE       =   ----     164
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:29:42 PAGE 7   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
