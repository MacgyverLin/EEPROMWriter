C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:00:52 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(9,SIZE) REGFILE(.\template.ORC) BROWSE D
                    -EBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          
   6          typedef enum
   7          {
   8                  INITIAL = 0,
   9                  CONNECTING,
  10                  CONNECTED,
  11                  PROGRAM_EEPROM_PAGE,
  12                  VERIFY_EEPROM_PAGE,
  13                  FAILED,
  14                  DONE
  15          }State;
  16          
  17          sbit CONNECTED_LED   = P3^0;
  18          sbit PROGRAM_LED     = P3^1;
  19          sbit VERIFY_LED      = P3^2;
  20          
  21          
  22          ////////////////////////////////////////////////////////////////////
  23          #define EEPROM_ADDRESS_L P0
  24          #define EEPROM_ADDRESS_H P1
  25          #define EEPROM_DATA P2
  26          
  27          sbit EEPROM_WR     = P3^7;
  28          sbit EEPROM_OE     = P3^6;
  29          sbit EEPROM_CE     = P3^5;
  30          
  31          #define SET_WR()                                        EEPROM_WR = 1
  32          #define SET_OE()                                        EEPROM_OE = 1
  33          #define SET_CE()                                        EEPROM_CE = 1
  34          #define CLR_WR()                                        EEPROM_WR = 0
  35          #define CLR_OE()                                        EEPROM_OE = 0
  36          #define CLR_CE()                                        EEPROM_CE = 0
  37          #define GET_WR()                                        EEPROM_WR
  38          #define GET_OE()                                        EEPROM_OE
  39          #define GET_CE()                                        EEPROM_CE
  40          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  41          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
  42          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  43          #define GET_EEPROM_DATA()                       EEPROM_DATA
  44          
  45          void setAddress(unsigned int addr)
  46          {
  47   1              SET_EEPROM_ADDRESS_L(addr & 0xff);
  48   1              SET_EEPROM_ADDRESS_H(addr >> 8);
  49   1      }
  50          
  51          void setData(unsigned char dat)
  52          {
  53   1              SET_EEPROM_DATA(dat);
  54   1      }
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:00:52 PAGE 2   

  55          
  56          unsigned char getData()
  57          {
  58   1              return GET_EEPROM_DATA();
  59   1      }
  60          
  61          void initEEPROWriter()
  62          {
  63   1              setAddress(0xffff);
  64   1              setData(0xff);
  65   1              SET_WR();
  66   1              SET_OE();
  67   1              SET_CE();
  68   1              
  69   1              delayMS(10);
  70   1      }
  71          
  72          void beginWriteByte()
  73          {
  74   1              setAddress(0xffff);
  75   1              setData(0xff);
  76   1              SET_WR();
  77   1              SET_OE();
  78   1              SET_CE();
  79   1      }
  80          
  81          void writeByte(unsigned int address, unsigned char dat)
  82          {
  83   1              setAddress(address);
  84   1              setData(dat);
  85   1              delay1us();
*** WARNING C206 IN LINE 85 OF MAIN.C: 'delay1us': missing function-prototype
  86   1      
  87   1              CLR_CE();
  88   1              delay1us();
  89   1              CLR_WR();
  90   1              delay1us();
  91   1      
  92   1              SET_CE();
  93   1              delay1us();
  94   1              SET_WR();
  95   1              delay1us();
  96   1      }
  97          
  98          void beginReadByte()
  99          {
 100   1              setAddress(0xffff);
 101   1              setData(0xff);
 102   1              delay1us();
 103   1      
 104   1              SET_CE();
 105   1              SET_WR();
 106   1              SET_OE();
 107   1      }
 108          
 109          unsigned char readByte(unsigned int address)
 110          {
 111   1              unsigned char dat;
 112   1      
 113   1              setAddress(address);
 114   1              delay1us();
 115   1      
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:00:52 PAGE 3   

 116   1              CLR_CE();
 117   1              delay1us();
 118   1              CLR_OE();
 119   1              delay1us();
 120   1      
 121   1              dat = getData();
 122   1              delay1us();
 123   1      
 124   1              SET_CE();
 125   1              delay1us();
 126   1              SET_OE();
 127   1              delay1us();
 128   1      
 129   1              return dat;
 130   1      }
 131          
 132          void endWriteByte()
 133          {
 134   1              delayMS(1000);
 135   1      }
 136          
 137          void endReadByte()
 138          {
 139   1              delayMS(1000);
 140   1      }
 141          
 142          void disableDataProtection()
 143          {
 144   1              writeByte(0x5555, 0xaa);
 145   1              writeByte(0x2aaa, 0x55);
 146   1              writeByte(0x5555, 0x80);
 147   1              writeByte(0x5555, 0xaa);
 148   1              writeByte(0x2aaa, 0x55);
 149   1              writeByte(0x5555, 0x20);
 150   1      }
 151          
 152          char programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 153          {
 154   1              int i;
 155   1              unsigned char d;
 156   1              unsigned char failed = 0;
 157   1              unsigned char t = 0;
 158   1      
 159   1              beginWriteByte();
 160   1              disableDataProtection();
 161   1      
 162   1              beginWriteByte();
 163   1              for(i=0; i<size; i++)
 164   1              {
 165   2                      writeByte(startAddress+i, dat[i]);
 166   2              }
 167   1              endWriteByte();
 168   1      
 169   1              beginReadByte();
 170   1              for(i=0; i<size; i++)
 171   1              {
 172   2                      d = readByte(startAddress+i);
 173   2                      if(d!=dat[i])
 174   2                              return 0;
 175   2              }
 176   1              endReadByte();
 177   1              
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:00:52 PAGE 4   

 178   1              return -1;
 179   1      }
 180          
 181          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 182          {
 183   1              int i;
 184   1              unsigned char d;
 185   1              unsigned char failed = 0;
 186   1              unsigned char t = 0;
 187   1      
 188   1              beginReadByte();
 189   1              for(i=0; i<size; i++)
 190   1              {
 191   2                      d = readByte(startAddress+i);
 192   2                      if(d!=dat[i])
 193   2                              return 0;
 194   2              }
 195   1              endReadByte();
 196   1              
 197   1              return -1;
 198   1      }
 199          
 200          void main()
 201          {
 202   1              State state = INITIAL;
 203   1              unsigned char rxBuffer[128];
 204   1              
 205   1              CONNECTED_LED   = 0;
 206   1              PROGRAM_LED     = 0;
 207   1              VERIFY_LED      = 0;
 208   1              
 209   1              while(1)
 210   1              {
 211   2                      switch(state)
 212   2                      {
 213   3                              case INITIAL:
 214   3                                      serialInitialize(9600);
 215   3                              
 216   3                                      state = CONNECTING;
 217   3                                      break;
 218   3      
 219   3                              case CONNECTING:
 220   3                              {
 221   4                                      serialReceiveData(rxBuffer, 1, 500); // wait for command C
 222   4      
 223   4                                      CONNECTED_LED = ~CONNECTED_LED;
 224   4                                      
 225   4                                      if(*rxBuffer == 'C')
 226   4                                      {
 227   5                                              serialSendData('c', 1, 500); // ack
 228   5                                              
 229   5                                              state = CONNECTED;       // connected
 230   5                                      }
 231   4                                      else
 232   4                                      {
 233   5                                              state = INITIAL;        // set next baud
 234   5                                      }                               
 235   4                              }
 236   3                              break;
 237   3                                      
 238   3                              case CONNECTED:
 239   3                              {
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:00:52 PAGE 5   

 240   4                                      CONNECTED_LED = 1;              
 241   4                              
 242   4                                      serialReceiveData(rxBuffer, 1, -1); // wait for command P or V
 243   4      
 244   4                                      if(*rxBuffer == 'P')
 245   4                                      {
 246   5                                              serialSendData('p', 1, 500);     // ack
 247   5                                              
 248   5                                              state = PROGRAM_EEPROM_PAGE;     // program
 249   5                                      }
 250   4                                      else if(*rxBuffer == 'V')
 251   4                                      {
 252   5                                              serialSendData('v', 1, 500);     // ack
 253   5                                              
 254   5                                              state = VERIFY_EEPROM_PAGE;      // verify
 255   5                                      }       
 256   4                                      else if(*rxBuffer == 'D')
 257   4                                      {
 258   5                                              serialSendData('d', 1, 500);     // ack
 259   5                                              
 260   5                                              state = DONE;    // verify
 261   5                                      }                                       
 262   4                                      else
 263   4                                      {
 264   5                                              state = CONNECTED; // unknown command, again
 265   5                                      }
 266   4                              }
 267   3                              break;
 268   3                                      
 269   3                              case PROGRAM_EEPROM_PAGE:
 270   3                              {
 271   4                                      unsigned int address;
 272   4                                      unsigned int size;
 273   4                                      
 274   4                                      serialReceiveData(rxBuffer, 1+4+4, -1); // wait for command P or V
 275   4                                      if(*rxBuffer == 'P')
 276   4                                      {
 277   5                                              address = *((unsigned int*)(rxBuffer+1));
 278   5                                              size    = *((unsigned int*)(rxBuffer+1+4));
 279   5                                              
 280   5                                              assert(size<=128);
 281   5                                              serialReceiveData(rxBuffer, size, -1); // wait for command P or V
 282   5                                              
 283   5                                              PROGRAM_LED     = 1;
 284   5                                              
 285   5                                              if(programPage(address, rxBuffer, size))
 286   5                                              {
 287   6                                                      PROGRAM_LED     = 0;
 288   6                                              
 289   6                                                      serialSendData('s', 1, -1);      // ack success
 290   6                                                      
 291   6                                                      state = CONNECTED; // unknown command, again
 292   6                                              }
 293   5                                              else
 294   5                                              {
 295   6                                                      PROGRAM_LED     = 0;
 296   6                                              
 297   6                                                      serialSendData('f', 1, -1);      // ack failed
 298   6                                                      
 299   6                                                      state = FAILED; // unknown command, again
 300   6                                              }
 301   5                                      }
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:00:52 PAGE 6   

 302   4                              }
 303   3                              break;
 304   3                              
 305   3                              case VERIFY_EEPROM_PAGE:
 306   3                              {
 307   4                                      unsigned int address;
 308   4                                      unsigned int size;
 309   4                                      
 310   4                                      serialReceiveData(rxBuffer, 1+4+4, -1); // wait for command P or V
 311   4                                      if(*rxBuffer == 'S')
 312   4                                      {
 313   5                                              address = *((unsigned int*)(rxBuffer+1));
 314   5                                              size    = *((unsigned int*)(rxBuffer+1+4));
 315   5                                              
 316   5                                              assert(size<=128);
 317   5                                              serialReceiveData(rxBuffer, size, -1); // wait for command P or V
 318   5                                              
 319   5                                              VERIFY_LED     = 1;
 320   5                                              
 321   5                                              if(verifyPage(address, rxBuffer, size))
 322   5                                              {
 323   6                                                      VERIFY_LED     = 0;
 324   6                                              
 325   6                                                      serialSendData('s', 1, -1);      // ack success
 326   6      
 327   6                                                      state = CONNECTED;
 328   6                                              }
 329   5                                              else
 330   5                                              {
 331   6                                                      VERIFY_LED     = 0;
 332   6                                              
 333   6                                                      serialSendData('f', 1, -1);      // ack failed  
 334   6                                                      
 335   6                                                      state = FAILED;
 336   6                                              }                                       
 337   5                                      }
 338   4                              }
 339   3                              break;
 340   3                              
 341   3                              case FAILED:
 342   3                              {
 343   4                                      delayMS(250);
 344   4                                      VERIFY_LED      = VERIFY_LED;
 345   4                              }
 346   3                              break;
 347   3                              
 348   3                              case DONE:
 349   3                              {
 350   4                                      VERIFY_LED      = 1;
 351   4                              }
 352   3                              break;
 353   3                      }
 354   2              }
 355   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    987    ----
   CONSTANT SIZE    =     51    ----
   XDATA SIZE       =   ----     156
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
C51 COMPILER V9.01   MAIN                                                                  02/28/2019 18:00:52 PAGE 7   

   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
