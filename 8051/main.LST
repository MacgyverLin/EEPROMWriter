C51 COMPILER V9.01   MAIN                                                                  03/01/2019 01:43:21 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE main.c COMPACT ROM(COMPACT) OPTIMIZE(9,SIZE) REGFILE(.\template.ORC) BROWSE
                    - DEBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          
   6          typedef enum
   7          {
   8                  INITIAL = 0,
   9                  CONNECTING,
  10                  CONNECTED,
  11                  PROGRAM_EEPROM_PAGE,
  12                  VERIFY_EEPROM_PAGE,
  13                  FAILED,
  14                  DONE
  15          }State;
  16          
  17          sbit CONNECTED_LED   = P3^2;
  18          sbit PROGRAM_LED     = P3^3;
  19          sbit VERIFY_LED      = P3^4;
  20          
  21          void displayState(int state)
  22          {                                       
  23   1              CONNECTED_LED = (state & 0x01) ? 0 : 1;
  24   1              PROGRAM_LED = (state & 0x02) ? 0 : 1;
  25   1              VERIFY_LED = (state & 0x04) ? 0 : 1;
  26   1      }
  27          
  28          void delay()
  29          {
  30   1              unsigned int i = 0;
  31   1      
  32   1              while(i++<10000);
  33   1      }
  34          
  35          ////////////////////////////////////////////////////////////////////
  36          #define EEPROM_ADDRESS_L P0
  37          #define EEPROM_ADDRESS_H P1
  38          #define EEPROM_DATA P2
  39          
  40          sbit EEPROM_WR     = P3^7;
  41          sbit EEPROM_OE     = P3^6;
  42          sbit EEPROM_CE     = P3^5;
  43          
  44          #define SET_WR()                                        EEPROM_WR = 1
  45          #define SET_OE()                                        EEPROM_OE = 1
  46          #define SET_CE()                                        EEPROM_CE = 1
  47          #define CLR_WR()                                        EEPROM_WR = 0
  48          #define CLR_OE()                                        EEPROM_OE = 0
  49          #define CLR_CE()                                        EEPROM_CE = 0
  50          #define GET_WR()                                        EEPROM_WR
  51          #define GET_OE()                                        EEPROM_OE
  52          #define GET_CE()                                        EEPROM_CE
  53          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  54          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 01:43:21 PAGE 2   

  55          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  56          #define GET_EEPROM_DATA()                       EEPROM_DATA
  57          
  58          void setAddress(unsigned int addr)
  59          {
  60   1              SET_EEPROM_ADDRESS_L(addr & 0xff);
  61   1              SET_EEPROM_ADDRESS_H(addr >> 8);
  62   1      }
  63          
  64          void setData(unsigned char dat)
  65          {
  66   1              SET_EEPROM_DATA(dat);
  67   1      }
  68          
  69          unsigned char getData()
  70          {
  71   1              return GET_EEPROM_DATA();
  72   1      }
  73          
  74          void initEEPROWriter()
  75          {
  76   1              setAddress(0xffff);
  77   1              setData(0xff);
  78   1              SET_WR();
  79   1              SET_OE();
  80   1              SET_CE();
  81   1              
  82   1              delayMS(10);
  83   1      }
  84          
  85          void beginWriteByte()
  86          {
  87   1              setAddress(0xffff);
  88   1              setData(0xff);
  89   1              SET_WR();
  90   1              SET_OE();
  91   1              SET_CE();
  92   1      }
  93          
  94          void writeByte(unsigned int address, unsigned char dat)
  95          {
  96   1              setAddress(address);
  97   1              setData(dat);
  98   1              delay1us();
  99   1      
 100   1              CLR_CE();
 101   1              delay1us();
 102   1              CLR_WR();
 103   1              delay1us();
 104   1      
 105   1              SET_CE();
 106   1              delay1us();
 107   1              SET_WR();
 108   1              delay1us();
 109   1      }
 110          
 111          void beginReadByte()
 112          {
 113   1              setAddress(0xffff);
 114   1              setData(0xff);
 115   1              delay1us();
 116   1      
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 01:43:21 PAGE 3   

 117   1              SET_CE();
 118   1              SET_WR();
 119   1              SET_OE();
 120   1      }
 121          
 122          unsigned char readByte(unsigned int address)
 123          {
 124   1              unsigned char dat;
 125   1      
 126   1              setAddress(address);
 127   1              delay1us();
 128   1      
 129   1              CLR_CE();
 130   1              delay1us();
 131   1              CLR_OE();
 132   1              delay1us();
 133   1      
 134   1              dat = getData();
 135   1              delay1us();
 136   1      
 137   1              SET_CE();
 138   1              delay1us();
 139   1              SET_OE();
 140   1              delay1us();
 141   1      
 142   1              return dat;
 143   1      }
 144          
 145          void endWriteByte()
 146          {
 147   1              delayMS(1000);
 148   1      }
 149          
 150          void endReadByte()
 151          {
 152   1              delayMS(1000);
 153   1      }
 154          
 155          void disableDataProtection()
 156          {
 157   1              writeByte(0x5555, 0xaa);
 158   1              writeByte(0x2aaa, 0x55);
 159   1              writeByte(0x5555, 0x80);
 160   1              writeByte(0x5555, 0xaa);
 161   1              writeByte(0x2aaa, 0x55);
 162   1              writeByte(0x5555, 0x20);
 163   1      }
 164          
 165          char programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 166          {
 167   1              int i;
 168   1              unsigned char d;
 169   1              unsigned char failed = 0;
 170   1              unsigned char t = 0;
 171   1      
 172   1              beginWriteByte();
 173   1              disableDataProtection();
 174   1      
 175   1              beginWriteByte();
 176   1              for(i=0; i<size; i++)
 177   1              {
 178   2                      writeByte(startAddress+i, dat[i]);
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 01:43:21 PAGE 4   

 179   2              }
 180   1              endWriteByte();
 181   1      
 182   1              beginReadByte();
 183   1              for(i=0; i<size; i++)
 184   1              {
 185   2                      d = readByte(startAddress+i);
 186   2                      if(d!=dat[i])
 187   2                              return 0;
 188   2              }
 189   1              endReadByte();
 190   1              
 191   1              return -1;
 192   1      }
 193          
 194          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 195          {
 196   1              int i;
 197   1              unsigned char d;
 198   1              unsigned char failed = 0;
 199   1              unsigned char t = 0;
 200   1      
 201   1              beginReadByte();
 202   1              for(i=0; i<size; i++)
 203   1              {
 204   2                      d = readByte(startAddress+i);
 205   2                      if(d!=dat[i])
 206   2                              return 0;
 207   2              }
 208   1              endReadByte();
 209   1              
 210   1              return -1;
 211   1      }
 212          
 213          void main()
 214          {       
 215   1              State state = INITIAL;
 216   1              char* rxBuffer;
 217   1      
 218   1              while(1)
 219   1              {
 220   2                      displayState(state);
 221   2                      switch(state)
 222   2                      {
 223   3                              case INITIAL:
 224   3                              {
 225   4                                      serialInitialize(9600);
 226   4                                      state = CONNECTING;
 227   4                              }
 228   3                              break;
 229   3      
 230   3                              case CONNECTING:
 231   3                              {
 232   4                                      serialReceiveData(1, 500); // wait for command C
 233   4      
 234   4                                      //CONNECTED_LED = ~CONNECTED_LED;
 235   4                                      
 236   4                                      rxBuffer = serialGetReceivedData(0);
 237   4                                      if(*rxBuffer == 'C')
 238   4                                      {
 239   5                                              serialSendData("c", 1, 500); // ack
 240   5                                              
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 01:43:21 PAGE 5   

 241   5                                              state = CONNECTED;       // connected
 242   5                                      }
 243   4                                      else
 244   4                                      {
 245   5                                              state = INITIAL;        // set next baud
 246   5                                      }                               
 247   4                              }
 248   3                              break;
 249   3                                      
 250   3                              case CONNECTED:
 251   3                              {
 252   4                                      // CONNECTED_LED = 1;           
 253   4                              
 254   4                                      serialReceiveData(1, -1); // wait for command P or V
 255   4      
 256   4                                      rxBuffer = serialGetReceivedData(0);
 257   4                                      if(*rxBuffer == 'P')
 258   4                                      {
 259   5                                              serialSendData("p", 1, 500);     // ack
 260   5                                              
 261   5                                              state = PROGRAM_EEPROM_PAGE;     // program
 262   5                                      }
 263   4                                      else if(*rxBuffer == 'V')
 264   4                                      {
 265   5                                              serialSendData("v", 1, 500);     // ack
 266   5                                              
 267   5                                              state = VERIFY_EEPROM_PAGE;      // verify
 268   5                                      }       
 269   4                                      else if(*rxBuffer == 'D')
 270   4                                      {
 271   5                                              serialSendData('d', 1, 500);     // ack
 272   5                                              
 273   5                                              state = DONE;    // verify
 274   5                                      }                                       
 275   4                                      else
 276   4                                      {
 277   5                                              state = CONNECTED; // unknown command, again
 278   5                                      }
 279   4                              }
 280   3                              break;
 281   3                                      
 282   3                              case PROGRAM_EEPROM_PAGE:
 283   3                              {
 284   4                                      unsigned long address;
 285   4                                      unsigned long size;
 286   4                                      
 287   4                                      serialReceiveData(1+4+4, -1); // wait for command P or V
 288   4                                      rxBuffer = serialGetReceivedData(0);
 289   4                                      if(*rxBuffer == 'P')
 290   4                                      {
 291   5                                              address = *((unsigned long*)(rxBuffer+1));
 292   5                                              size    = *((unsigned long*)(rxBuffer+1+4));
 293   5                                              
 294   5                                              assert(size<=128);
 295   5                                              serialReceiveData(size, -1); // wait for command P or V
 296   5                                              
 297   5                                              //PROGRAM_LED     = 1;
 298   5                                              rxBuffer = serialGetReceivedData(0);
 299   5                                              if(programPage(address, rxBuffer, size))
 300   5                                              {
 301   6                                                      //PROGRAM_LED     = 0;
 302   6                                              
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 01:43:21 PAGE 6   

 303   6                                                      serialSendData("s", 1, -1);      // ack success
 304   6                                                      
 305   6                                                      state = CONNECTED; // unknown command, again
 306   6                                              }
 307   5                                              else
 308   5                                              {
 309   6                                                      //PROGRAM_LED     = 0;
 310   6                                              
 311   6                                                      serialSendData("f", 1, -1);      // ack failed
 312   6                                                      
 313   6                                                      state = FAILED; // unknown command, again
 314   6                                              }
 315   5                                      }
 316   4                              }
 317   3                              break;
 318   3                              
 319   3                              case VERIFY_EEPROM_PAGE:
 320   3                              {
 321   4                                      unsigned long address;
 322   4                                      unsigned long size;
 323   4                                      
 324   4                                      serialReceiveData(1+4+4, -1); // wait for command P or V
 325   4                                      rxBuffer = serialGetReceivedData(0);
 326   4                                      if(*rxBuffer == 'S')
 327   4                                      {
 328   5                                              address = *((unsigned long*)(rxBuffer+1));
 329   5                                              size    = *((unsigned long*)(rxBuffer+1+4));
 330   5                                              
 331   5                                              assert(size<=128);
 332   5                                              serialReceiveData(size, -1); // wait for command P or V
 333   5                                              
 334   5                                              // VERIFY_LED     = 1;
 335   5                                              rxBuffer = serialGetReceivedData(0);
 336   5                                              if(verifyPage(address, rxBuffer, size))
 337   5                                              {
 338   6                                                      // VERIFY_LED     = 0;
 339   6                                              
 340   6                                                      serialSendData("s", 1, -1);      // ack success
 341   6      
 342   6                                                      state = CONNECTED;
 343   6                                              }
 344   5                                              else
 345   5                                              {
 346   6                                                      // VERIFY_LED     = 0;
 347   6                                              
 348   6                                                      serialSendData("f", 1, -1);      // ack failed  
 349   6                                                      
 350   6                                                      state = FAILED;
 351   6                                              }                                       
 352   5                                      }
 353   4                              }
 354   3                              break;
 355   3                              
 356   3                              case FAILED:
 357   3                              {
 358   4                                      // VERIFY_LED      = VERIFY_LED;
 359   4                              }
 360   3                              break;
 361   3                              
 362   3                              case DONE:
 363   3                              {
 364   4                                      // VERIFY_LED      = 1;
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 01:43:21 PAGE 7   

 365   4                              }
 366   3                              break;
 367   3                      }
 368   2              }
 369   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    989    ----
   CONSTANT SIZE    =     61    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----      34
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
