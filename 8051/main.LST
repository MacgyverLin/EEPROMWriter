C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN main.OBJ
COMPILER INVOKED BY: E:\Keil\C51\BIN\C51.EXE main.c LARGE ROM(COMPACT) OPTIMIZE(9,SIZE) BROWSE DEBUG OBJECTEXTEND

line level    source

   1          #include "serial.h"
   2          #include "delay.h"
   3          #include "reg52.h"
   4          #include <assert.h>
   5          #include <string.h>
   6          
   7          typedef enum
   8          {
   9                  INITIAL = 0,
  10                  CONNECTING,
  11                  CONNECTED,
  12                  PROGRAM_EEPROM_PAGE,
  13                  VERIFY_EEPROM_PAGE,
  14                  FAILED,
  15                  DONE
  16          }State;
  17          
  18          sbit CONNECTED_LED   = P3^2;
  19          sbit PROGRAM_LED     = P3^3;
  20          sbit VERIFY_LED      = P3^4;
  21          
  22          void displayState(int state)
  23          {                                       
  24   1              CONNECTED_LED = (state & 0x01) ? 0 : 1;
  25   1              PROGRAM_LED = (state & 0x02) ? 0 : 1;
  26   1              VERIFY_LED = (state & 0x04) ? 0 : 1;
  27   1      }
  28          
  29          void delay()
  30          {
  31   1              unsigned int i = 0;
  32   1      
  33   1              while(i++<10000);
  34   1      }
  35          
  36          ////////////////////////////////////////////////////////////////////
  37          #define EEPROM_ADDRESS_L P0
  38          #define EEPROM_ADDRESS_H P1
  39          #define EEPROM_DATA P2
  40          
  41          sbit EEPROM_WR     = P3^7;
  42          sbit EEPROM_OE     = P3^6;
  43          sbit EEPROM_CE     = P3^5;
  44          
  45          #define SET_WR()                                        EEPROM_WR = 1
  46          #define SET_OE()                                        EEPROM_OE = 1
  47          #define SET_CE()                                        EEPROM_CE = 1
  48          #define CLR_WR()                                        EEPROM_WR = 0
  49          #define CLR_OE()                                        EEPROM_OE = 0
  50          #define CLR_CE()                                        EEPROM_CE = 0
  51          #define GET_WR()                                        EEPROM_WR
  52          #define GET_OE()                                        EEPROM_OE
  53          #define GET_CE()                                        EEPROM_CE
  54          #define SET_EEPROM_ADDRESS_L(addrl) EEPROM_ADDRESS_L = addrl
  55          #define SET_EEPROM_ADDRESS_H(addrh) EEPROM_ADDRESS_H = addrh
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 2   

  56          #define SET_EEPROM_DATA(data)           EEPROM_DATA = data
  57          #define GET_EEPROM_DATA()                       EEPROM_DATA
  58          
  59          void setAddress(unsigned int addr)
  60          {
  61   1              SET_EEPROM_ADDRESS_L(addr & 0xff);
  62   1              SET_EEPROM_ADDRESS_H(addr >> 8);
  63   1      }
  64          
  65          void setData(unsigned char dat)
  66          {
  67   1              SET_EEPROM_DATA(dat);
  68   1      }
  69          
  70          unsigned char getData()
  71          {
  72   1              return GET_EEPROM_DATA();
  73   1      }
  74          
  75          void initEEPROWriter()
  76          {
  77   1              setAddress(0xffff);
  78   1              setData(0xff);
  79   1              SET_WR();
  80   1              SET_OE();
  81   1              SET_CE();
  82   1              
  83   1              delayMS(10);
  84   1      }
  85          
  86          void beginWriteByte()
  87          {
  88   1              setAddress(0xffff);
  89   1              setData(0xff);
  90   1              SET_WR();
  91   1              SET_OE();
  92   1              SET_CE();
  93   1      }
  94          
  95          void writeByte(unsigned int address, unsigned char dat)
  96          {
  97   1              setAddress(address);
  98   1              setData(dat);
  99   1              delay1us();
 100   1      
 101   1              CLR_CE();
 102   1              delay1us();
 103   1              CLR_WR();
 104   1              delay1us();
 105   1      
 106   1              SET_CE();
 107   1              delay1us();
 108   1              SET_WR();
 109   1              delay1us();
 110   1      }
 111          
 112          void beginReadByte()
 113          {
 114   1              setAddress(0xffff);
 115   1              setData(0xff);
 116   1              delay1us();
 117   1      
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 3   

 118   1              SET_CE();
 119   1              SET_WR();
 120   1              SET_OE();
 121   1      }
 122          
 123          unsigned char readByte(unsigned int address)
 124          {
 125   1              unsigned char dat;
 126   1      
 127   1              setAddress(address);
 128   1              delay1us();
 129   1      
 130   1              CLR_CE();
 131   1              delay1us();
 132   1              CLR_OE();
 133   1              delay1us();
 134   1      
 135   1              dat = getData();
 136   1              delay1us();
 137   1      
 138   1              SET_CE();
 139   1              delay1us();
 140   1              SET_OE();
 141   1              delay1us();
 142   1      
 143   1              return dat;
 144   1      }
 145          
 146          void endWriteByte()
 147          {
 148   1              delayMS(1000);
 149   1      }
 150          
 151          void endReadByte()
 152          {
 153   1              delayMS(1000);
 154   1      }
 155          
 156          void disableDataProtection()
 157          {
 158   1              writeByte(0x5555, 0xaa);
 159   1              writeByte(0x2aaa, 0x55);
 160   1              writeByte(0x5555, 0x80);
 161   1              writeByte(0x5555, 0xaa);
 162   1              writeByte(0x2aaa, 0x55);
 163   1              writeByte(0x5555, 0x20);
 164   1      }
 165          
 166          void programPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 167          {
 168   1              int i;
 169   1              unsigned char d;
 170   1              unsigned char failed = 0;
 171   1              unsigned char t = 0;
 172   1      
 173   1              beginWriteByte();
 174   1              disableDataProtection();
 175   1      
 176   1              beginWriteByte();
 177   1              for(i=0; i<size; i++)
 178   1              {
 179   2                      writeByte(startAddress+i, dat[i]);
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 4   

 180   2              }
 181   1              endWriteByte();
 182   1              
 183   1              delayMS(100);   
 184   1      }
*** WARNING C280 IN LINE 169 OF MAIN.C: 'd': unreferenced local variable
 185          
 186          char verifyPage(unsigned int startAddress, unsigned char* dat, unsigned int size)
 187          {
 188   1              int i;
 189   1              unsigned char d;
 190   1              unsigned char failed = 0;
 191   1              unsigned char t = 0;
 192   1      
 193   1              beginReadByte();
 194   1              for(i=0; i<size; i++)
 195   1              {
 196   2                      d = readByte(startAddress+i);
 197   2                      if(d!=dat[i])
 198   2                              return 0;
 199   2              }
 200   1              endReadByte();
 201   1              
 202   1              return -1;
 203   1      }
 204          
 205          unsigned long int convertToBigEndian32(unsigned long int v)
 206          {
 207   1              return ((v>>24) & 0x000000ff) | ((v>>8) & 0x0000ff00) | ((v<<8) & 0x00ff0000) | ((v<<24) & 0xff00000);
 208   1      }
 209          
 210          code char temp[] = {
 211                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 212                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 213                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 214                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 215          
 216                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 217                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 218                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 219                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 220                  
 221                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 222                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 223                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 224                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 225          
 226                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 227                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 228                                                  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 
 229                                  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 
 230                                                  };
 231          
 232          void main()
 233          {
 234   1              #if 0
                      char test = 0;
                      programPage(0, temp, 128);
                      test = verifyPage(0, temp, 128);
                      while(1)
                      {
                              if(!test)
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 5   

                              {
                                      delayMS(250);
                                      EEPROM_CE      = ~EEPROM_CE;
                              }
                              else
                              {
                                      EEPROM_CE      = 0;
                              }
                      };
                      #else
 251   1              State state = INITIAL;
 252   1              char* rxBuffer = 0;
 253   1      
 254   1              while(1)
 255   1              {
 256   2                      switch(state)
 257   2                      {
 258   3                              case INITIAL:
 259   3                              {
 260   4                                      displayState(state);                            
 261   4                                      serialInitialize(9600);
 262   4                                      state = CONNECTING;
 263   4                              }
 264   3                              break;
 265   3      
 266   3                              case CONNECTING:
 267   3                              {
 268   4                                      displayState(state);                            
 269   4                                      rxBuffer = serialReceiveData(1, 500); // wait for command C
 270   4      
 271   4                                      //CONNECTED_LED = ~CONNECTED_LED;
 272   4                                      if(*rxBuffer == 'C') 
 273   4                                      {
 274   5                                              serialSendData("c", 1, 500); // ack
 275   5                                              
 276   5                                              state = CONNECTED;       // connected
 277   5                                      }
 278   4                                      else
 279   4                                      {
 280   5                                              state = INITIAL;        // set next baud
 281   5                                      }                               
 282   4                              }
 283   3                              break;
 284   3                                      
 285   3                              case CONNECTED:
 286   3                              {
 287   4                                      displayState(state);                            
 288   4                                      // CONNECTED_LED = 1;           
 289   4                              
 290   4                                      rxBuffer = serialReceiveData(1, -1); // wait for command P or V
 291   4                                      if(*rxBuffer == 'P')
 292   4                                      {
 293   5                                              serialSendData("p", 1, 500);     // ack
 294   5                                              
 295   5                                              displayState(PROGRAM_EEPROM_PAGE);
 296   5                                              
 297   5                                              state = PROGRAM_EEPROM_PAGE;     // program
 298   5                                      }
 299   4                                      else if(*rxBuffer == 'V')
 300   4                                      {
 301   5                                              serialSendData("v", 1, 500);     // ack
 302   5                                              
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 6   

 303   5                                              displayState(VERIFY_EEPROM_PAGE);
 304   5                                              
 305   5                                              state = VERIFY_EEPROM_PAGE;      // verify
 306   5                                      }       
 307   4                                      else if(*rxBuffer == 'D')
 308   4                                      {
 309   5                                              serialSendData('d', 1, 500);     // ack
 310   5                                              
 311   5                                              state = DONE;    // verify
 312   5                                      }                                       
 313   4                                      else
 314   4                                      {
 315   5                                              state = CONNECTED; // unknown command, again
 316   5                                      }
 317   4                              }
 318   3                              break;
 319   3                                      
 320   3                              case PROGRAM_EEPROM_PAGE:
 321   3                              {
 322   4                                      unsigned long int address;
 323   4                                      unsigned long int size;
 324   4                                      
 325   4                                      rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
 326   4                                      if(*rxBuffer == 'P')
 327   4                                      {
 328   5                                              address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
 329   5                                              size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
 330   5                                              /*
 331   5                                              displayState(1);                                         
 332   5      
 333   5                                              sprintf(rxBuffer, "a:%lx", address);
 334   5                                              serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
 335   5                                              displayState(2);
 336   5                                              
 337   5                                              sprintf(rxBuffer, "s:%lx", size);
 338   5                                              serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
 339   5                                              displayState(3);                                        
 340   5                                              
 341   5                                              serialReceiveData(size, -1); // wait for command P or V
 342   5                                              displayState(4);
 343   5                                              
 344   5                                              //serialSendData(rxBuffer, 16, -1);      // ack success
 345   5                                              displayState(5);
 346   5                                              */
 347   5                                              
 348   5                                              //sprintf(rxBuffer, "a:%lx", address);
 349   5                                              //serialSendData(rxBuffer, strlen(rxBuffer), 500);       // ack                         
 350   5                                              
 351   5                                              //sprintf(rxBuffer, "s:%lx", size);
 352   5                                              //serialSendData(rxBuffer, strlen(rxBuffer), 500);       // ack                         
 353   5                                              
 354   5                                              //PROGRAM_LED     = 1;
 355   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
 356   5                                              programPage(address, rxBuffer, size);
 357   5                                              if(verifyPage(address, rxBuffer, size))
 358   5                                              {
 359   6                                                      //PROGRAM_LED     = 0;
 360   6                                              
 361   6                                                      serialSendData("s", 1, -1);      // ack success
 362   6                                                      
 363   6                                                      state = DONE; // unknown command, again
 364   6                                              }
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 7   

 365   5                                              else
 366   5                                              {
 367   6                                                      //PROGRAM_LED     = 0;
 368   6                                              
 369   6                                                      serialSendData("f", 1, -1);      // ack failed
 370   6                                                      
 371   6                                                      state = FAILED; // unknown command, again
 372   6                                              }
 373   5                                      }
 374   4                                      else
 375   4                                      {
 376   5                                              serialSendData("f", 1, -1);      // ack failed
 377   5                                                      
 378   5                                              state = FAILED; // unknown command, again
 379   5                                      }
 380   4                              }
 381   3                              break;
 382   3                              
 383   3                              case VERIFY_EEPROM_PAGE:
 384   3                              {
 385   4                                      unsigned long int address;
 386   4                                      unsigned long int size;
 387   4                                      
 388   4                                      rxBuffer = serialReceiveData(1+4+4, -1); // wait for command P or V
 389   4                                      if(*rxBuffer == 'P')
 390   4                                      {
 391   5                                              address = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1))  );
 392   5                                              size    = convertToBigEndian32(*((unsigned long int*)(rxBuffer+1+4)));
 393   5                                              /*
 394   5                                              displayState(1);                                         
 395   5      
 396   5                                              sprintf(rxBuffer, "a:%lx", address);
 397   5                                              serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
 398   5                                              displayState(2);
 399   5                                              
 400   5                                              sprintf(rxBuffer, "s:%lx", size);
 401   5                                              serialSendData(rxBuffer, strlen(rxBuffer), 500);         // ack                         
 402   5                                              displayState(3);                                        
 403   5                                              
 404   5                                              serialReceiveData(size, -1); // wait for command P or V
 405   5                                              displayState(4);
 406   5                                              
 407   5                                              //serialSendData(rxBuffer, 16, -1);      // ack success
 408   5                                              displayState(5);
 409   5                                              */
 410   5                                              
 411   5                                              //sprintf(rxBuffer, "a:%lx", address);
 412   5                                              //serialSendData(rxBuffer, strlen(rxBuffer), 500);       // ack                         
 413   5                                              
 414   5                                              //sprintf(rxBuffer, "s:%lx", size);
 415   5                                              //serialSendData(rxBuffer, strlen(rxBuffer), 500);       // ack                         
 416   5                                              
 417   5                                              //PROGRAM_LED     = 1;
 418   5                                              rxBuffer = serialReceiveData(size, -1); // wait for command P or V                                      
 419   5                                              if(verifyPage(address, rxBuffer, size))
 420   5                                              {
 421   6                                                      //PROGRAM_LED     = 0;
 422   6                                              
 423   6                                                      serialSendData("s", 1, -1);      // ack success
 424   6                                                      
 425   6                                                      state = DONE; // unknown command, again
 426   6                                              }
C51 COMPILER V9.01   MAIN                                                                  03/01/2019 20:35:39 PAGE 8   

 427   5                                              else
 428   5                                              {
 429   6                                                      //PROGRAM_LED     = 0;
 430   6                                              
 431   6                                                      serialSendData("f", 1, -1);      // ack failed
 432   6                                                      
 433   6                                                      state = FAILED; // unknown command, again
 434   6                                              }
 435   5                                      }
 436   4                                      else
 437   4                                      {
 438   5                                              serialSendData("f", 1, -1);      // ack failed
 439   5                                                      
 440   5                                              state = FAILED; // unknown command, again
 441   5                                      }
 442   4                                      
 443   4                              }
 444   3                              break;
 445   3                              
 446   3                              case FAILED:
 447   3                              {
 448   4                                      delayMS(250);
 449   4                                      EEPROM_CE      = ~EEPROM_CE;
 450   4                              }
 451   3                              break;
 452   3                              
 453   3                              case DONE:
 454   3                              {
 455   4                                      EEPROM_CE      = 0;
 456   4                              }
 457   3                              break;
 458   3                      }
 459   2              }
 460   1              
 461   1              #endif
 462   1      } 


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1104    ----
   CONSTANT SIZE    =    138    ----
   XDATA SIZE       =   ----      40
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
